interface System where {

{-# NEED #-}
instance Prelude.Floating Prelude.Float;

{-# NEED #-}
instance Prelude.Floating Prelude.Double;

{-# NEED #-}
instance Prelude.RealFloat Prelude.Float;

{-# NEED #-}
instance Prelude.RealFloat Prelude.Double;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Fractional Prelude.Float;

{-# NEED #-}
instance Prelude.Fractional Prelude.Double;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.RealFrac Prelude.Float;

{-# NEED #-}
instance Prelude.RealFrac Prelude.Double;

{-# NEED #-}
instance Prelude.Functor Prelude.IO;

{-# NEED #-}
instance Prelude.Functor Prelude.[];

{-# NEED #-}
instance Prelude.Functor Prelude.Maybe;

{-# NEED #-}
instance Prelude.Monad Prelude.IO;

{-# NEED #-}
instance Prelude.Monad Prelude.[];

{-# NEED #-}
instance Prelude.Monad Prelude.Maybe;

{-# NEED #-}
instance Prelude.Bounded Prelude.Char;

{-# NEED #-}
instance Prelude.Bounded Prelude.Ordering;

{-# NEED #-}
instance Prelude.Bounded Prelude.Bool;

{-# NEED #-}
instance Prelude.Bounded Prelude.Int;

{-# NEED #-}
instance Prelude.Bounded ();

{-# NEED #-}
instance (Prelude.Bounded a,Prelude.Bounded b,Prelude.Bounded c) => Prelude.Bounded (a,b,c);

{-# NEED #-}
instance (Prelude.Bounded a,Prelude.Bounded b) => Prelude.Bounded (a,b);

{-# NEED #-}
instance Prelude.Integral Prelude.Integer;

{-# NEED #-}
instance Prelude.Integral Prelude.Int;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Real Prelude.Integer;

{-# NEED #-}
instance Prelude.Real Prelude.Float;

{-# NEED #-}
instance Prelude.Real Prelude.Double;

{-# NEED #-}
instance Prelude.Real Prelude.Int;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Num Prelude.Integer;

{-# NEED #-}
instance Prelude.Num Prelude.Float;

{-# NEED #-}
instance Prelude.Num Prelude.Double;

{-# NEED #-}
instance Prelude.Num Prelude.Int;

{-# NEED #-}
instance Prelude.Enum Prelude.Char;

{-# NEED #-}
instance Prelude.Enum Prelude.Ordering;

{-# NEED #-}
instance Prelude.Enum Prelude.Bool;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum Prelude.Integer;

{-# NEED #-}
instance Prelude.Enum Prelude.Float;

{-# NEED #-}
instance Prelude.Enum Prelude.Double;

{-# NEED #-}
instance Prelude.Enum Prelude.Int;

{-# NEED #-}
instance Prelude.Enum ();

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord [a];

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Ord Prelude.Char;

{-# NEED #-}
instance Prelude.Ord Prelude.Ordering;

{-# NEED #-}
instance Prelude.Ord Prelude.Bool;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Ord Prelude.Integer;

{-# NEED #-}
instance Prelude.Ord Prelude.Float;

{-# NEED #-}
instance Prelude.Ord Prelude.Double;

{-# NEED #-}
instance Prelude.Ord Prelude.Int;

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.R a);

{-# NEED #-}
instance Prelude.Ord ExitCode;

{-# NEED #-}
instance Prelude.Ord ();

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c,Prelude.Ord d) => Prelude.Ord (a,b,c,d);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c) => Prelude.Ord (a,b,c);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (a,b);

{-# NEED #-}
instance Prelude.Eq Prelude.IOError;

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq [a];

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Eq Prelude.Char;

{-# NEED #-}
instance Prelude.Eq Prelude.Ordering;

{-# NEED #-}
instance Prelude.Eq Prelude.Bool;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Eq Prelude.Integer;

{-# NEED #-}
instance Prelude.Eq Prelude.Float;

{-# NEED #-}
instance Prelude.Eq Prelude.Double;

{-# NEED #-}
instance Prelude.Eq Prelude.Int;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.R a);

{-# NEED #-}
instance Prelude.Eq ExitCode;

{-# NEED #-}
instance Prelude.Eq ();

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c,Prelude.Eq d) => Prelude.Eq (a,b,c,d);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c) => Prelude.Eq (a,b,c);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (a,b);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read [a];

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Read Prelude.Char;

{-# NEED #-}
instance Prelude.Read Prelude.Ordering;

{-# NEED #-}
instance Prelude.Read Prelude.Bool;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Read Prelude.Integer;

{-# NEED #-}
instance Prelude.Read Prelude.Float;

{-# NEED #-}
instance Prelude.Read Prelude.Double;

{-# NEED #-}
instance Prelude.Read Prelude.Int;

{-# NEED #-}
instance Prelude.Read ExitCode;

{-# NEED #-}
instance Prelude.Read ();

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c,Prelude.Read d) => Prelude.Read (a,b,c,d);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c) => Prelude.Read (a,b,c);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (a,b);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.IO a);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a -> b);

{-# NEED #-}
instance Prelude.Show Prelude.IOError;

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show [a];

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Show Prelude.Char;

{-# NEED #-}
instance Prelude.Show Prelude.Ordering;

{-# NEED #-}
instance Prelude.Show Prelude.Bool;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Show Prelude.Integer;

{-# NEED #-}
instance Prelude.Show Prelude.Float;

{-# NEED #-}
instance Prelude.Show Prelude.Double;

{-# NEED #-}
instance Prelude.Show Prelude.Int;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.R a);

{-# NEED #-}
instance Prelude.Show ExitCode;

{-# NEED #-}
instance Prelude.Show ();

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c,Prelude.Show d) => Prelude.Show (a,b,c,d);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c) => Prelude.Show (a,b,c);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a,b);

interface Prelude
{-# NEED Bounded #-}
class Bounded a;

{-# NEED Read #-}
class Read a;

{-# NEED World #-}
data World;

{-# NEED Void #-}
data Void;

{-# NEED RList #-}
data RList a;

{-# NEED E #-}
data E a;

{-# NEED Value #-}
data Value;

{-# NEED _Value #-}
data _Value;

{-# NEED IOError #-}
data IOError;

{-# NEED Either #-}
data Either a b;

{-# NEED [] #-}
data [] a;

{-# NEED Maybe #-}
data Maybe a;
interface Prelude
{-# NEED Ordering #-}
data Ordering;
interface Prelude
{-# NEED #-}
data ();

{-# NEED #-}
data (,,,,,,,,,) a b c d e f g h i j;

{-# NEED #-}
data (,,,,,,,,) a b c d e f g h i;

{-# NEED #-}
data (,,,,,,,) a b c d e f g h;

{-# NEED #-}
data (,,,,,,) a b c d e f g;

{-# NEED #-}
data (,,,,,) a b c d e f;

{-# NEED #-}
data (,,,,) a b c d e;

{-# NEED #-}
data (,,,) a b c d;

{-# NEED #-}
data (,,) a b c;

{-# NEED #-}
data (,,,,,,,,,,,) a b c d e f g h i j k l;

{-# NEED #-}
data (,,,,,,,,,,) a b c d e f g h i j k;

{-# NEED #-}
data (,) a b;
interface ! System
{-# NEED exitWith #-}
exitWith{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R ExitCode) -> (Prelude.R (Prelude.IO a)))))));
interface Prelude
{-# NEED IO #-}
data IO a;

{-# NEED (->) #-}
data (->) a b;
interface ! System
{-# NEED {ExitCode ExitSuccess ExitFailure} #-}
data ExitCode
  = ExitSuccess 
  | ExitFailure (Prelude.R Prelude.Int);
interface Prelude
{-# NEED R #-}
data R a;

{-# NEED Traces Trace #-}
data Traces;
data Trace;

{-# NEED NmType #-}
data NmType;

{-# NEED Double #-}
data Double;

{-# NEED Float #-}
data Float;
interface Ratio
{-# NEED Rational #-}
type {-# 1 #-} Rational = (Ratio Prelude.Integer);

{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Prelude
{-# NEED Integral #-}
class (Prelude.Real a,Prelude.Enum a) => Integral a;

{-# NEED Enum #-}
class Enum a;

{-# NEED Real #-}
class (Prelude.Num a,Prelude.Ord a) => Real a;

{-# NEED Ord #-}
class (Prelude.Eq a) => Ord a;

{-# NEED Num #-}
class (Prelude.Eq a,Prelude.Show a) => Num a;

{-# NEED Show #-}
class Show a;

{-# NEED Eq #-}
class Eq a;

{-# NEED Integer #-}
data Integer;

{-# NEED Char #-}
data Char;

{-# NEED SR #-}
data SR;

{-# NEED Int #-}
data Int;

{-# NEED Bool #-}
data Bool;
}
