interface List where {
infix   5 \\;

interface Prelude
{-# NEED Read #-}
class Read a;

{-# NEED _Value #-}
data _Value;

{-# NEED World #-}
data World;

{-# NEED Void #-}
data Void;

{-# NEED Value #-}
data Value;

{-# NEED E #-}
data E a;

{-# NEED RList #-}
data RList a;

{-# NEED IOError #-}
data IOError;

{-# NEED Either #-}
data Either a b;
interface Prelude
{-# NEED Ordering #-}
data Ordering;

{-# NEED Maybe #-}
data Maybe a;

{-# NEED IO #-}
data IO a;

{-# NEED #-}
data (,,,,,,,,,,) a b c d e f g h i j k;

{-# NEED #-}
data (,,,,,,,,,,,) a b c d e f g h i j k l;

{-# NEED #-}
data (,,) a b c;

{-# NEED #-}
data (,,,) a b c d;

{-# NEED #-}
data (,,,,) a b c d e;

{-# NEED #-}
data (,,,,,) a b c d e f;

{-# NEED #-}
data (,,,,,,) a b c d e f g;

{-# NEED #-}
data (,,,,,,,) a b c d e f g h;

{-# NEED #-}
data (,,,,,,,,) a b c d e f g h i;

{-# NEED #-}
data (,,,,,,,,,) a b c d e f g h i j;

{-# NEED #-}
data ();
interface ! List
{-# NEED elemIndexBy #-}
elemIndexBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Int))))))))))));

{-# NEED sortBy #-}
sortBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Ordering))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED insertBy #-}
insertBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Ordering))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))))))))));
interface Prelude
{-# NEED Ordering #-}
data Ordering;
interface ! List
{-# NEED intersectBy #-}
intersectBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))))))))));

{-# NEED deleteFirstsBy #-}
deleteFirstsBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))))))))));

{-# NEED groupBy #-}
groupBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]])))))))));

{-# NEED lookupBy #-}
lookupBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [(a,b)]) -> (Prelude.R (Prelude.Maybe b)))))))))))));

{-# NEED unionBy #-}
unionBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))))))))));

{-# NEED maximumBy #-}
maximumBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R a))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R a)))))))));

{-# NEED minimumBy #-}
minimumBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R a))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R a)))))))));

{-# NEED notElemBy #-}
notElemBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R Prelude.Bool))))))))))));

{-# NEED elemBy #-}
elemBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R Prelude.Bool))))))))))));

{-# NEED deleteBy #-}
deleteBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))))))))));

{-# NEED nubBy #-}
nubBy{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED elemIndex #-}
elemIndex{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Maybe Prelude.Int))))))))));

{-# NEED findIndex #-}
findIndex{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Maybe Prelude.Int))))))))));

{-# NEED genericIndex #-}
genericIndex{-# 2 #-}::(Prelude.Integral b) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R a)))))))));

{-# NEED sort #-}
sort{-# 2 #-}::(Prelude.Ord a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))));

{-# NEED insert #-}
insert{-# 2 #-}::(Prelude.Ord a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED intersect #-}
intersect{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED genericSplitAt #-}
genericSplitAt{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R ([b],[b]))))))))));

{-# NEED deleteFirsts #-}
deleteFirsts{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED inits #-}
inits{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]]))))));

{-# NEED permutations #-}
permutations{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]]))))));

{-# NEED tails #-}
tails{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]]))))));

{-# NEED subsequences #-}
subsequences{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]]))))));

{-# NEED elemIndices #-}
elemIndices{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [Prelude.Int])))))))));

{-# NEED findIndices #-}
findIndices{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [Prelude.Int])))))))));

{-# NEED unfoldr #-}
unfoldr{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Maybe (b,a)))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R [b])))))))));

{-# NEED group #-}
group{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [[a]]))))));

{-# NEED genericDrop #-}
genericDrop{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R [b])))))))));

{-# NEED partition #-}
partition{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R ([a],[a]))))))))));
interface Prelude
{-# NEED #-}
data (,) a b;
interface ! List
{-# NEED union #-}
union{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED genericLength #-}
genericLength{-# 2 #-}::(Prelude.Num b) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R b))))));

{-# NEED isSuffixOf #-}
isSuffixOf{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R Prelude.Bool)))))))));

{-# NEED isPrefixOf #-}
isPrefixOf{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R Prelude.Bool)))))))));

{-# NEED delete #-}
delete{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED genericReplicate #-}
genericReplicate{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R [b])))))))));

{-# NEED intersperse #-}
intersperse{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED transpose #-}
transpose{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [[a]]) -> (Prelude.R [[a]]))))));

{-# NEED genericTake #-}
genericTake{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R [b])))))))));

{-# NEED (\\) #-}
(\\){-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a])))))))));

{-# NEED find #-}
find{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Maybe a))))))))));
interface Prelude
{-# NEED Maybe #-}
data Maybe a;
interface ! List
{-# NEED nub #-}
nub{-# 2 #-}::(Prelude.Eq a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R [a]))))));

{-# NEED mapAccumR #-}
mapAccumR{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (a,c)))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (a,[c])))))))))))));

{-# NEED mapAccumL #-}
mapAccumL{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (a,c)))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (a,[c])))))))))))));

{-# NEED unzip7 #-}
unzip7{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [(a,b,c,d,e,f,g)]) -> (Prelude.R ([a],[b],[c],[d],[e],[f],[g])))))));

{-# NEED zip7 #-}
zip7{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [f]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [g]) -> (Prelude.R [(a,b,c,d,e,f,g)]))))))))))))))))))))))));

{-# NEED zipWith7 #-}
zipWith7{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (Prelude.Trace -> ((Prelude.R c) -> (Prelude.R (Prelude.Trace -> ((Prelude.R d) -> (Prelude.R (Prelude.Trace -> ((Prelude.R e) -> (Prelude.R (Prelude.Trace -> ((Prelude.R f) -> (Prelude.R (Prelude.Trace -> ((Prelude.R g) -> (Prelude.R h)))))))))))))))))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [f]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [g]) -> (Prelude.R [h])))))))))))))))))))))))))));

{-# NEED unzip6 #-}
unzip6{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [(a,b,c,d,e,f)]) -> (Prelude.R ([a],[b],[c],[d],[e],[f])))))));

{-# NEED zip6 #-}
zip6{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [f]) -> (Prelude.R [(a,b,c,d,e,f)])))))))))))))))))))));

{-# NEED zipWith6 #-}
zipWith6{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (Prelude.Trace -> ((Prelude.R c) -> (Prelude.R (Prelude.Trace -> ((Prelude.R d) -> (Prelude.R (Prelude.Trace -> ((Prelude.R e) -> (Prelude.R (Prelude.Trace -> ((Prelude.R f) -> (Prelude.R g))))))))))))))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [f]) -> (Prelude.R [g]))))))))))))))))))))))));

{-# NEED unzip5 #-}
unzip5{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [(a,b,c,d,e)]) -> (Prelude.R ([a],[b],[c],[d],[e])))))));

{-# NEED zip5 #-}
zip5{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R [(a,b,c,d,e)]))))))))))))))))));

{-# NEED zipWith5 #-}
zipWith5{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (Prelude.Trace -> ((Prelude.R c) -> (Prelude.R (Prelude.Trace -> ((Prelude.R d) -> (Prelude.R (Prelude.Trace -> ((Prelude.R e) -> (Prelude.R f)))))))))))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [e]) -> (Prelude.R [f])))))))))))))))))))));

{-# NEED unzip4 #-}
unzip4{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [(a,b,c,d)]) -> (Prelude.R ([a],[b],[c],[d])))))));

{-# NEED zip4 #-}
zip4{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R [(a,b,c,d)])))))))))))))));

{-# NEED zipWith4 #-}
zipWith4{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R b) -> (Prelude.R (Prelude.Trace -> ((Prelude.R c) -> (Prelude.R (Prelude.Trace -> ((Prelude.R d) -> (Prelude.R e))))))))))))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [a]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [b]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [c]) -> (Prelude.R (Prelude.Trace -> ((Prelude.R [d]) -> (Prelude.R [e]))))))))))))))))));
interface Prelude
{-# NEED [] #-}
data [] a;

{-# NEED R #-}
data R a;

{-# NEED Trace Traces #-}
data Trace;
data Traces;

{-# NEED NmType #-}
data NmType;

{-# NEED Double #-}
data Double;

{-# NEED Float #-}
data Float;
interface Ratio
{-# NEED Rational #-}
type {-# 1 #-} Rational = (Ratio Prelude.Integer);

{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Prelude
{-# NEED Integral #-}
class (Prelude.Real a,Prelude.Enum a) => Integral a;

{-# NEED Enum #-}
class Enum a;

{-# NEED Real #-}
class (Prelude.Num a,Prelude.Ord a) => Real a;

{-# NEED Ord #-}
class (Prelude.Eq a) => Ord a;

{-# NEED Num #-}
class (Prelude.Eq a,Prelude.Show a) => Num a;

{-# NEED Show #-}
class Show a;

{-# NEED Integer #-}
data Integer;

{-# NEED Char #-}
data Char;

{-# NEED SR #-}
data SR;

{-# NEED Int #-}
data Int;

{-# NEED Bool #-}
data Bool;

{-# NEED (->) #-}
data (->) a b;

{-# NEED Eq #-}
class Eq a;
}
