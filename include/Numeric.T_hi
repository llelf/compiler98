interface Numeric where {

{-# NEED #-}
instance Prelude.Num Prelude.Int;

{-# NEED #-}
instance Prelude.Num Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Num Prelude.Float;

{-# NEED #-}
instance Prelude.Num Prelude.Double;

{-# NEED #-}
instance Prelude.Real Prelude.Int;

{-# NEED #-}
instance Prelude.Real Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Real Prelude.Float;

{-# NEED #-}
instance Prelude.Real Prelude.Double;

{-# NEED #-}
instance Prelude.Integral Prelude.Int;

{-# NEED #-}
instance Prelude.Integral Prelude.Integer;

{-# NEED #-}
instance Prelude.Enum Prelude.Bool;

{-# NEED #-}
instance Prelude.Enum Prelude.Int;

{-# NEED #-}
instance Prelude.Enum Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum Prelude.Float;

{-# NEED #-}
instance Prelude.Enum Prelude.Double;

{-# NEED #-}
instance Prelude.Enum Prelude.Char;

{-# NEED #-}
instance Prelude.Enum ();

{-# NEED #-}
instance Prelude.Enum Prelude.Ordering;

{-# NEED #-}
instance Prelude.Ord Prelude.Bool;

{-# NEED #-}
instance Prelude.Ord Prelude.Int;

{-# NEED #-}
instance Prelude.Ord Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Ord Prelude.Float;

{-# NEED #-}
instance Prelude.Ord Prelude.Double;

{-# NEED #-}
instance Prelude.Ord Prelude.Char;

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (a,b);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord [a];

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.R a);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c) => Prelude.Ord (a,b,c);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c,Prelude.Ord d) => Prelude.Ord (a,b,c,d);

{-# NEED #-}
instance Prelude.Ord ();

{-# NEED #-}
instance Prelude.Ord Prelude.Ordering;

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Eq Prelude.Bool;

{-# NEED #-}
instance Prelude.Eq Prelude.Int;

{-# NEED #-}
instance Prelude.Eq Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Eq Prelude.Float;

{-# NEED #-}
instance Prelude.Eq Prelude.Double;

{-# NEED #-}
instance Prelude.Eq Prelude.Char;

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (a,b);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq [a];

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.R a);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c) => Prelude.Eq (a,b,c);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c,Prelude.Eq d) => Prelude.Eq (a,b,c,d);

{-# NEED #-}
instance Prelude.Eq ();

{-# NEED #-}
instance Prelude.Eq Prelude.Ordering;

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Eq Prelude.IOError;

{-# NEED #-}
instance Prelude.Functor Prelude.[];

{-# NEED #-}
instance Prelude.Functor Prelude.Maybe;

{-# NEED #-}
instance Prelude.Functor Prelude.IO;

{-# NEED #-}
instance Prelude.Monad Prelude.[];

{-# NEED #-}
instance Prelude.Monad Prelude.Maybe;

{-# NEED #-}
instance Prelude.Monad Prelude.IO;

{-# NEED #-}
instance Prelude.Show Prelude.Bool;

{-# NEED #-}
instance Prelude.Show Prelude.Int;

{-# NEED #-}
instance Prelude.Show Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Show Prelude.Float;

{-# NEED #-}
instance Prelude.Show Prelude.Double;

{-# NEED #-}
instance Prelude.Show Prelude.Char;

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a,b);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show [a];

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.R a);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a -> b);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c) => Prelude.Show (a,b,c);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c,Prelude.Show d) => Prelude.Show (a,b,c,d);

{-# NEED #-}
instance Prelude.Show ();

{-# NEED #-}
instance Prelude.Show Prelude.Ordering;

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Show Prelude.IOError;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.IO a);

{-# NEED #-}
instance Prelude.Read Prelude.Bool;

{-# NEED #-}
instance Prelude.Read Prelude.Int;

{-# NEED #-}
instance Prelude.Read Prelude.Integer;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Read Prelude.Float;

{-# NEED #-}
instance Prelude.Read Prelude.Double;

{-# NEED #-}
instance Prelude.Read Prelude.Char;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (a,b);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read [a];

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c) => Prelude.Read (a,b,c);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c,Prelude.Read d) => Prelude.Read (a,b,c,d);

{-# NEED #-}
instance Prelude.Read ();

{-# NEED #-}
instance Prelude.Read Prelude.Ordering;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (Prelude.Either a b);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Prelude.Maybe a);
interface Prelude
{-# NEED IOError #-}
data IOError;

{-# NEED IO #-}
data IO a;

{-# NEED #-}
data (,,) a b c;

{-# NEED #-}
data (,,,) a b c d;

{-# NEED #-}
data ();

{-# NEED Ordering #-}
data Ordering;

{-# NEED Either #-}
data Either a b;

{-# NEED Read #-}
class Read a;

{-# NEED Maybe #-}
data Maybe a;
interface ! Numeric
{-# NEED readHex #-}
readHex{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)]))))));

{-# NEED showInt #-}
showInt{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R Prelude.String)))))))));

{-# NEED readInt #-}
readInt{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.Char) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.Char) -> (Prelude.R Prelude.Int)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)])))))))))))))));

{-# NEED readOct #-}
readOct{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)]))))));

{-# NEED showFloat #-}
showFloat{-# 2 #-}::(Prelude.RealFloat a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.ShowS))))));

{-# NEED readFloat #-}
readFloat{-# 2 #-}::(Prelude.RealFloat a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)]))))));

{-# NEED lexDigits #-}
lexDigits{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(Prelude.String,Prelude.String)]))))));

{-# NEED nonnull #-}
nonnull{-# 2 #-}::(Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.Char) -> (Prelude.R Prelude.Bool)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(Prelude.String,Prelude.String)])))))))));

{-# NEED readDec #-}
readDec{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)]))))));

{-# NEED showSigned #-}
showSigned{-# 2 #-}::(Prelude.Num a,Prelude.Ord a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.ShowS)))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.Int) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R Prelude.ShowS))))))))))));

{-# NEED readSigned #-}
readSigned{-# 2 #-}::(Prelude.Real a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)])))) -> (Prelude.R (Prelude.Trace -> ((Prelude.R Prelude.String) -> (Prelude.R [(a,Prelude.String)])))))))));
interface Prelude
{-# NEED #-}
data (,) a b;

{-# NEED String #-}
type {-# 1 #-} String = [Char];

{-# NEED [] #-}
data [] a;

{-# NEED R #-}
data R a;

{-# NEED Trace Traces #-}
data Trace;
data Traces;

{-# NEED NmType #-}
data NmType;

{-# NEED Double #-}
data Double;

{-# NEED Float #-}
data Float;
interface Ratio
{-# NEED Rational #-}
type {-# 1 #-} Rational = (Ratio.Ratio Prelude.Integer);

{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Prelude
{-# NEED Integer #-}
data Integer;

{-# NEED Char #-}
data Char;

{-# NEED SR #-}
data SR;

{-# NEED Int #-}
data Int;

{-# NEED Bool #-}
data Bool;

{-# NEED (->) #-}
data (->) a b;

{-# NEED Integral #-}
class (Prelude.Real a,Prelude.Enum a) => Integral a;

{-# NEED Enum #-}
class Enum a;

{-# NEED Real #-}
class (Prelude.Num a,Prelude.Ord a) => Real a;

{-# NEED Ord #-}
class (Prelude.Eq a) => Ord a;

{-# NEED Num #-}
class (Prelude.Eq a,Prelude.Show a) => Num a;

{-# NEED Show #-}
class Show a;

{-# NEED Eq #-}
class Eq a;
}
