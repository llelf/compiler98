interface Ratio where {
infixl  7 %;

{-# NEED #-}
instance Prelude.Functor Prelude.IO;

{-# NEED #-}
instance Prelude.Functor Prelude.[];

{-# NEED #-}
instance Prelude.Functor Prelude.Maybe;

{-# NEED #-}
instance Prelude.Monad Prelude.IO;

{-# NEED #-}
instance Prelude.Monad Prelude.[];

{-# NEED #-}
instance Prelude.Monad Prelude.Maybe;

{-# NEED #-}
instance Prelude.Real Prelude.Int;

{-# NEED #-}
instance Prelude.Real Prelude.Double;

{-# NEED #-}
instance Prelude.Real Prelude.Float;

{-# NEED #-}
instance Prelude.Real Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio a);

{-# NEED #-}
instance Prelude.Num Prelude.Int;

{-# NEED #-}
instance Prelude.Num Prelude.Double;

{-# NEED #-}
instance Prelude.Num Prelude.Float;

{-# NEED #-}
instance Prelude.Num Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio a);

{-# NEED #-}
instance Prelude.Integral Prelude.Int;

{-# NEED #-}
instance Prelude.Integral Prelude.Integer;

{-# NEED #-}
instance Prelude.Enum Prelude.Ordering;

{-# NEED #-}
instance Prelude.Enum Prelude.Char;

{-# NEED #-}
instance Prelude.Enum Prelude.Bool;

{-# NEED #-}
instance Prelude.Enum Prelude.Int;

{-# NEED #-}
instance Prelude.Enum Prelude.Double;

{-# NEED #-}
instance Prelude.Enum Prelude.Float;

{-# NEED #-}
instance Prelude.Enum Prelude.Integer;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio a);

{-# NEED #-}
instance Prelude.Enum ();

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord [a];

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.Maybe a);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (Prelude.Either a b);

{-# NEED #-}
instance Prelude.Ord Prelude.Ordering;

{-# NEED #-}
instance Prelude.Ord Prelude.Char;

{-# NEED #-}
instance Prelude.Ord Prelude.Bool;

{-# NEED #-}
instance Prelude.Ord Prelude.Int;

{-# NEED #-}
instance Prelude.Ord Prelude.Double;

{-# NEED #-}
instance Prelude.Ord Prelude.Float;

{-# NEED #-}
instance Prelude.Ord Prelude.Integer;

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Prelude.R a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio a);

{-# NEED #-}
instance Prelude.Ord ();

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c,Prelude.Ord d) => Prelude.Ord (a,b,c,d);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b,Prelude.Ord c) => Prelude.Ord (a,b,c);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (a,b);

{-# NEED #-}
instance Prelude.Eq Prelude.IOError;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq [a];

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.Maybe a);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (Prelude.Either a b);

{-# NEED #-}
instance Prelude.Eq Prelude.Ordering;

{-# NEED #-}
instance Prelude.Eq Prelude.Char;

{-# NEED #-}
instance Prelude.Eq Prelude.Bool;

{-# NEED #-}
instance Prelude.Eq Prelude.Int;

{-# NEED #-}
instance Prelude.Eq Prelude.Double;

{-# NEED #-}
instance Prelude.Eq Prelude.Float;

{-# NEED #-}
instance Prelude.Eq Prelude.Integer;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Prelude.R a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio a);

{-# NEED #-}
instance Prelude.Eq ();

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c,Prelude.Eq d) => Prelude.Eq (a,b,c,d);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b,Prelude.Eq c) => Prelude.Eq (a,b,c);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (a,b);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read [a];

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Prelude.Maybe a);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (Prelude.Either a b);

{-# NEED #-}
instance Prelude.Read Prelude.Ordering;

{-# NEED #-}
instance Prelude.Read Prelude.Char;

{-# NEED #-}
instance Prelude.Read Prelude.Bool;

{-# NEED #-}
instance Prelude.Read Prelude.Int;

{-# NEED #-}
instance Prelude.Read Prelude.Double;

{-# NEED #-}
instance Prelude.Read Prelude.Float;

{-# NEED #-}
instance Prelude.Read Prelude.Integer;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio a);

{-# NEED #-}
instance Prelude.Read ();

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c,Prelude.Read d) => Prelude.Read (a,b,c,d);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b,Prelude.Read c) => Prelude.Read (a,b,c);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Read b) => Prelude.Read (a,b);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a -> b);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.IO a);

{-# NEED #-}
instance Prelude.Show Prelude.IOError;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show [a];

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.Maybe a);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (Prelude.Either a b);

{-# NEED #-}
instance Prelude.Show Prelude.Ordering;

{-# NEED #-}
instance Prelude.Show Prelude.Char;

{-# NEED #-}
instance Prelude.Show Prelude.Bool;

{-# NEED #-}
instance Prelude.Show Prelude.Int;

{-# NEED #-}
instance Prelude.Show Prelude.Double;

{-# NEED #-}
instance Prelude.Show Prelude.Float;

{-# NEED #-}
instance Prelude.Show Prelude.Integer;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Prelude.R a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio a);

{-# NEED #-}
instance Prelude.Show ();

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c,Prelude.Show d) => Prelude.Show (a,b,c,d);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b,Prelude.Show c) => Prelude.Show (a,b,c);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (a,b);
interface Prelude
{-# NEED Read #-}
class Read a;

{-# NEED IO #-}
data IO a;

{-# NEED IOError #-}
data IOError;

{-# NEED [] #-}
data [] a;
interface Prelude
{-# NEED Maybe #-}
data Maybe a;

{-# NEED Either #-}
data Either a b;

{-# NEED Ordering #-}
data Ordering;
interface Prelude
{-# NEED #-}
data ();

{-# NEED #-}
data (,,,) a b c d;

{-# NEED #-}
data (,,) a b c;

{-# NEED #-}
data (,) a b;
interface ! Ratio
{-# NEED numerator #-}
numerator{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Ratio a)) -> (Prelude.R a))))));

{-# NEED denominator #-}
denominator{-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R (Ratio a)) -> (Prelude.R a))))));

{-# NEED (%) #-}
(%){-# 2 #-}::(Prelude.Integral a) => (Prelude.SR -> (Prelude.Trace -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Prelude.Trace -> ((Prelude.R a) -> (Prelude.R (Ratio a))))))))));
interface Prelude
{-# NEED R #-}
data R a;

{-# NEED Trace Traces #-}
data Trace;
data Traces;

{-# NEED NmType #-}
data NmType;

{-# NEED Double #-}
data Double;

{-# NEED Float #-}
data Float;

{-# NEED Char #-}
data Char;

{-# NEED SR #-}
data SR;

{-# NEED Int #-}
data Int;

{-# NEED Bool #-}
data Bool;

{-# NEED (->) #-}
data (->) a b;
interface ! Ratio
{-# NEED Rational #-}
type {-# 1 #-} Rational = (Ratio Prelude.Integer);
interface Prelude
{-# NEED Integer #-}
data Integer;
interface ! Ratio
{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Prelude
{-# NEED Integral #-}
class (Prelude.Real a,Prelude.Enum a) => Integral a;

{-# NEED Enum #-}
class Enum a;

{-# NEED Real #-}
class (Prelude.Num a,Prelude.Ord a) => Real a;

{-# NEED Ord #-}
class (Prelude.Eq a) => Ord a;

{-# NEED Num #-}
class (Prelude.Eq a,Prelude.Show a) => Num a;

{-# NEED Show #-}
class Show a;

{-# NEED Eq #-}
class Eq a;
}
