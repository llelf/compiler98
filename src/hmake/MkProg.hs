module Main(main) where
import Argv
import GetDep
import Getmodtime(isOld,When,show_When)
import ListUtil(lconcatMap,assocDef,pair)
import Order
import Output
import IO
import System


main =
 getArgs >>= \ args ->
 let
  (zdefs, defs, dflag, ifdebug, ifnotopt, ifopt, isopt,
   goalDir, ignoreHi, pathSrc, pathPrel, modules) = decode args

  keepPrelude = isopt "keepPrelude"

  order' g = (scctsort . map (\(f,(tps,i)) -> (f,i))) g

  build_graph mods =
	-- First, get a list of all the important info about every file
	-- that might be touched.
    dependency unix (zdefs++defs) keepPrelude goalDir ignoreHi []
               ("":pathSrc ++ if keepPrelude then pathPrel else [])
               pathPrel (map stripGoal mods) >>= \nhcgOrg ->
	-- 'nhcgOrg' is a list of (file, (timestamps,imports))
      let	-- 'src' is the simple list of source files.
          src = map fst nhcgOrg
		-- 'nhcg' removes prelude imports from the import lists
          nhcg = map (\(f,(tpsc,i)) -> (f,(tpsc,filter (`elem` src) i))) nhcgOrg
		-- 'cnhcg'' removes timestamps, finds strongly connected
		-- components, and orders them.
          cnhcg' =  order' nhcg
		-- 'cycles' identifies cyclic dependencies
          cycles = filter ((1 /=) . length) cnhcg'
		-- 'nhcg'' is the flattened scc list
          nhcg' = concat cnhcg'
		-- 'hsT' and 'hiT' build assoc-lists of static timestamps
          hsT = hsTimes nhcg nhcg'
          hiT = hiTimes nhcg nhcg'
          hiP = hiPaths nhcg nhcg'
		-- 'graph' calculates which files definitely need to be
		-- compiled based on initial timestamps, and which ones
		-- might need to be compiled, depending on whether some
		-- imported modules' .hi files changed or not.
          graph = makeGraph hsT [] hiT hiP
      in
        return (cycles,graph,nhcg)

  makeGraph []                 hiT' hiT hiP = []
  makeGraph ((hs,(st,ot,p,s,cpp,dep)):hsT) hiT' hiT hiP = 
	-- If at least one of the imported .hi files or the source file
	-- is younger than the object file, then we definitely recompile.
      if or (map (isOld ot) (st:map (assocDef hiT (undefModule "???")) dep)) then
        ([],(p,hs,s,cpp)): makeGraph hsT (hs:hiT') hiT hiP
      else
	-- Otherwise, we need to build a dynamic dependency on those .hi files
	-- which might change (due to cycles).  But if all the imported .hi's
	-- have already been seen, we leave this one alone.
        case filter (`elem` hiT') dep of
            [] -> makeGraph hsT hiT' hiT hiP
            xs -> (map impPath xs, (p,hs,s,cpp)): makeGraph hsT (hs:hiT') hiT hiP
    where impPath x = (x, assocDef hiP (undefModule x) x)

  hsTimes g m = map (\v-> (v, hsTime (assocDef g (undefModule v) v))) m
     where hsTime (((hsT,_,oT),p,s,cpp),i) = (hsT,oT,p,s,cpp,i)

  hiTimes g m = map (\v-> (v, hiTime (assocDef g (undefModule v) v))) m
     where hiTime (((_,hiT,_),p,s,cpp),i) = hiT

  hiPaths g m = map (\v-> (v, hiPath (assocDef g (undefModule v) v))) m
     where hiPath (((_,_,_),p,s,cpp),i) = p

  undefModule m = error ("undefined module "++show m++"\n")
  unix = True	-- formerly (isopt "unix")
  echo = not (isopt "q")

 in
  if null modules then
      hPutStr stderr "Usage: MkProg [-q] [-dobjdir] [-g] [-M] target ...\n"
  else
      build_graph modules >>= \(cycles,build,nhcg)->
      let objcmds = lconcatMap (qCompile echo goalDir dflag defs unix) build
          execmds = lconcatMap (qLink    echo goalDir dflag unix nhcg) modules
      in hPutStr stderr
             (if null cycles then ""
              else "Cycles:\n" ++ lconcatMap ((++ "\n") . show) cycles)
	   >>
         putStr (
           ifdebug "Dependency graph:\n" ++
           ifopt ["g"] (lconcatMap showdep nhcg))
           >>
         putStr (
           ifopt ["M"] ("# dependencies generated by hmake -M:\n" ++
                        lconcatMap (showmake unix dflag goalDir) nhcg))
           >>
         putStr (
           ifopt ["Md"] ("# dependencies generated by hmake -Md:\n" ++
                         "OBJDIR=" ++ goalDir ++ "\n" ++
                         lconcatMap (showmake unix dflag "${OBJDIR}") nhcg))
           >>
         putStr (
           ifdebug "Commands:\n" ++
           ifnotopt ["g", "M", "Md"] (objcmds ++ execmds))
