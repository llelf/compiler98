module Main(main) where
import Argv
import GetDep
import Getmodtime(isOld,When,show_When)
import ListUtil(lconcatMap,assocDef,pair)
import Order
import Output
import IO
import System


main =
 getArgs >>= \ args ->
 let
  d = decode args
  echo = not (quiet d)

  order' g = (scctsort . map (\(f,(tps,i)) -> (f,i))) g
  fdeps  g = map (\(f,((t,p,s,c),is)) ->
                     ((f,p,s)
                     , map (\i->(i, path (assocDef g (undefModule i) i))) is
                     )
                 ) g
     where path ((t,p,s,cpp),i) = p

  build_graph mods =
	-- First, get a list of all the important info about every file
	-- that might be touched.
    dependency d [] (map (\m->(stripGoal m,"commandline")) mods) >>= \nhcgOrg ->
	-- 'nhcgOrg' is a list of (file, (timestamps,imports))
      let	-- 'src' is the simple list of source files.
          src = map fst nhcgOrg
		-- 'nhcg' removes prelude imports from the import lists
          nhcg = map (\(f,(tpsc,i)) -> (f,(tpsc,filter (`elem` src) i))) nhcgOrg
		-- 'cnhcg'' removes timestamps, finds strongly connected
		-- components, and orders them.
          cnhcg' =  order' nhcg
		-- 'cycles' identifies cyclic dependencies
          cycles = filter ((1 /=) . length) cnhcg'
		-- 'nhcg'' is the flattened scc list
          nhcg' = concat cnhcg'
		-- 'hsT' and 'hiT' build assoc-lists of static timestamps
          hsT = hsTimes nhcg nhcg'
          hiT = hiTimes nhcg nhcg'
          hiP = hiPaths nhcg nhcg'
		-- 'graph' calculates which files definitely need to be
		-- compiled based on initial timestamps, and which ones
		-- might need to be compiled, depending on whether some
		-- imported modules' .hi files changed or not.
          graph = makeGraph hsT [] hiT hiP
      in
        return (cycles,graph,nhcg,fdeps nhcg)

  makeGraph []                 hiT' hiT hiP = []
  makeGraph ((hs,(st,ot,p,s,cpp,dep)):hsT) hiT' hiT hiP = 
	-- If at least one of the imported .hi files or the source file
	-- is younger than the object file, then we definitely recompile.
      if or (map (isOld ot) (st:map (assocDef hiT (undefModule "??")) dep)) then
        ([],(p,hs,s,cpp)): makeGraph hsT (hs:hiT') hiT hiP
      else
	-- Otherwise, we need to build a dynamic dependency on those .hi files
	-- which might change (due to cycles).  But if all the imported .hi's
	-- have already been seen, we leave this one alone.
        case filter (`elem` hiT') dep of
            [] -> makeGraph hsT hiT' hiT hiP
            xs -> (map impPath xs, (p,hs,s,cpp)):
                  makeGraph hsT (hs:hiT') hiT hiP
    where impPath x = (x, assocDef hiP (undefModule x) x)

  hsTimes g m = map (\v-> (v, hsTime (assocDef g (undefModule v) v))) m
     where hsTime (((hsT,_,oT),p,s,cpp),i) = (hsT,oT,p,s,cpp,i)

  hiTimes g m = map (\v-> (v, hiTime (assocDef g (undefModule v) v))) m
     where hiTime (((_,hiT,_),p,s,cpp),i) = hiT

  hiPaths g m = map (\v-> (v, hiPath (assocDef g (undefModule v) v))) m
     where hiPath (((_,_,_),p,s,cpp),i) = p

  undefModule m = error ("undefined module "++show m++"\n")

 in
  if null (modules d) then
      hPutStr stderr ("Usage: MkProg [-q] [-dobjdir] [-g] [-M] target ...\n"
                     ++"    [must have at least one target]\n")
  else
      build_graph (modules d) >>= \(cycles,build,nhcg,fdep)->
      let objcmds = lconcatMap (qCompile d echo)      build
          execmds = lconcatMap (qLink    d echo nhcg) (modules d)
          cleano  = lconcatMap (qCleano  d echo nhcg) (modules d)
          cleanhi = lconcatMap (qCleanhi d echo nhcg) (modules d)
      in do
         hPutStr stderr
             (if null cycles then ""
              else "Cycles:\n" ++ lconcatMap ((++ "\n") . show) cycles)
         putStr (
           ifopt d ["g"] (lconcatMap showdep nhcg))
         putStr (
           ifopt d ["M"]
                   ("# dependencies generated by hmake -M:\n" ++
                    lconcatMap (showmake d (goalDir d)) fdep))
         putStr (
           ifopt d ["Md"]
                   ("# dependencies generated by hmake -Md:\n" ++
                    "OBJDIR=" ++ (goalDir d) ++ "\n" ++
                    lconcatMap (showmake d "${OBJDIR}") fdep))
         putStr (
           ifopt d ["clean","realclean"] cleano ++
           ifopt d ["realclean"] cleanhi)
         putStr (
           ifnotopt d ["g", "M", "Md", "clean", "realclean"]
                      (objcmds ++ execmds))
