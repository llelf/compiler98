@A@<Garbage collection: Mark phase@>

This section provides marking support for the garbage collector.

@O@<mark.c@>==@{@-
@<File warning@>

#include "node.h"
#include "mark.h"
#include "mutlib.h"

@<CAF lists@>

@<addCaf routine@>

@<marked routine@>
@<unmarked routine@>
@<ifmarked routine@>

@<markClear routine@>
@<mark routine@>
@<markStack routine@>
@<markCaf routine@>
@}

@O@<mark.h@>==@{
#ifndef _MARK_H
#define _MARK_H

@<File warning@>

@<Pointer location macros@>

extern @<marked header@>;
extern @<ifmarked header@>;

extern @<markClear header@>;
extern @<mark header@>;
extern @<markStack header@>;
extern @<markCaf header@>;

#endif
@}

@$@<Mark phase interface@>==@{@-
@<CAF lists type@>

@<Export CAF lists@>
extern @<addCaf header@>;
@}

@B@<The bit table@>

Past the heap and stack areas proper, we maintain a bit table that records
a one bit mark for each word in the allocated area.  The space for the
table is allocated in @{initGc@} and @{bitTable@} set to its start address.

@C@<Marking, unmarking and checking marks@>

The routines @{marked@}, @{unmarked@} and @{ifmarked@} provide the basic
interface to the bit table.  @{marked@} returns true if the provided node
is already marked, otherwise it marks it and returns false.

@$@<marked header@>@M==@{@-
UInt marked(NodePtr node)@-
@}

@$@<marked routine@>==@{@-
@<marked header@>
{
    UInt off = node - hpLowLimit;
    UInt mask = 1l << (off & WORDMASK);

    off >>= WORDSHIFT;
    if (bitTable[off] & mask)
        return 1;
    bitTable[off] |= mask;
    return 0;
}
@}

@{unmarked@} just turns the mark off for the argument node.

@$@<unmarked routine@>==@{@-
void unmarked(NodePtr node)
{
    UInt off = node - hpLowLimit;
    UInt mask = 1l << (off & WORDMASK);
    off >>= WORDSHIFT;
    bitTable[off] &= ~mask;
}
@}

@{ifmarked@} returns the marked status of the argument node.

@$@<ifmarked header@>@M==@{@-
UInt ifmarked(NodePtr node)@-
@}

@$@<ifmarked routine@>==@{@-
@<ifmarked header@>
{
    UInt off = node - hpLowLimit;
    UInt mask = 1l << (off & WORDMASK);
    off >>= WORDSHIFT;
    if (bitTable[off] & mask)
        return 1;
    return 0;
}
@}

@C@<Clearing all of the marks@>

The first step in the mark phase is to clear all of the marks using
@{markClear@}.  The exception is the node at @{hpLowLimit@} that is marked
and used as a sentinel to stop the marking process (see below).  See also
the initialisation of the heap which sets up this special node in the low
heap area.

FIXME: confirm what the ~0 is used for.  Confirm the explanation of the
marking of hpLowLimit.

@$@<markClear header@>@M==@{@-
void markClear(void)@-
@}

@$@<markClear routine@>==@{@-
@<markClear header@>
{
    NodePtr p;
    for (p = bitTable; p < hpEnd; *p++ = 0)
        ;
    hpEnd[-1] = ~0;
    marked(hpLowLimit);
}
@}

@B@<Node locations@>

We need to be able to tell whether a pointer lies inside the heap
(@{INSIDE@}) or outside of it (@{OUTSIDE@}).  Also, a pointer inside the
heap may be in the stack area (@{ONSTACK@}).

@$@<Pointer location macros@>==@{@-
#define OUTSIDE(n)  ((n <  hpLowLimit) || (n >= bitTable))
#define INSIDE(n)   ((n >= hpLowLimit) && (n <  bitTable))
#define ONSTACK(n)  ((n >= (NodePtr)spEnd) && (n <  (NodePtr)spStart))
@}

@B@<Marking the stack@>

The stack contains a sequence of frames.  Reading from the top, each frame
consists of its saved @{ip@}, its saved @{fp@} and a sequence of words
holding the content of the frame.  The saved @{fp@} points to the saved
@{ip@} of the previous frame.  (See the @{PUSH_STATE@} macro in the
mutator for the implementation.)

To mark nodes reachable from the stack we traverse the length of the stack
(from @{sp@} to @{spStart@}) picking up the @{(ip,fp)@} pairs.  For each
pair, we skip the @{ip@}, and use the @{fp@} to continue down the stack to
the start of the next frame.  Each word encountered in this region is
marked.

FIXME: what guarantees that a (fp,ip) pair is currently at tos and not
something else?

@$@<markStack header@>@M==@{@-
void markStack(NodePtr *sp)@-
@}

@$@<markStack routine@>==@{@-
@<markStack header@>
{
    NodePtr *sptr;
    for (sptr = sp; sptr < spStart; ) {
        NodePtr *fp;
        sptr++;
        fp = (NodePtr *)*sptr++;
        while(sptr != fp) {
            mark(sptr);
            sptr++;
        }
    }
}
@}

@B@<Marking CAFs@>

A constant applicative form (CAF) is a supercombinator of arity zero.
Since they have no arguments, they are never instantiated and a single
instance of their graph can be shared.

@C@<CAF lists@>

To keep track of CAFs the collector uses two linked lists.  The
@{sizeArity@} field holds in its first half-word the size in words of the
data addressed by the @{ptr@} field.  The second half-word holds the arity
(not used by the collector).  Note that this matches the layout for
functions as described for the graph structure.

FIXME: clarify this.  It looks like the word containing the @{next@} field
is overwriting stuff in the other parts of the function descriptor.

FIXME: not sure what the second half of this comment from the code means:
/* size is in sizeArity + (1+EXTRA) extra if arity == 0 */

@$@<CAF lists type@>+=@{@-
typedef struct GCCONST {
    int sizeArity;
    struct GCCONST *next;
    NodePtr ptr[1];
} *GcConst;
@}

@{GcEnd@} indicates the end of a linked list.

@$@<CAF lists type@>+=@{@-
#define GcEnd ((GcConst)-1)
@}

@{newCaf@} contains CAFs encountered during the marking phase, and
@{oldCaf@} the CAFs that have been processed by the mark phase but need to
be flipped by the next collector phase.

@$@<CAF lists@>==@{@-
GcConst oldCaf = GcEnd;
GcConst newCaf = GcEnd;
@}

@$@<Export CAF lists@>==@{@-
extern GcConst oldCaf;
@}

CAFs are added to the @{newCaf@} list using @{addCaf@} that just links
them in at the head of the list.

@$@<addCaf header@>@M==@{@-
void addCaf(Finfo finfo)@-
@}

@$@<addCaf routine@>==@{@-
static void addCaf2(UInt cons)
{
    GcConst cptr = (GcConst)cons;
    if (!cptr->next) {
        cptr->next = newCaf;
        newCaf = cptr;
    }
}

@<addCaf header@>
{
    addCaf2((UInt)FINFO_CONST(finfo));
}
@}

@C@<Actually marking CAFs@>

The @{newCAF@} list is used as a work list to keep track of CAFs that are
encountered during marking but still have to be processed by the marker.
@{markCaf@} traverses the @{newCaf@} list until there are no more CAFs to
process.  As nodes are removed from @{newCaf@} they are added to
@{oldCaf@} so that the next phase can find them.

@$@<markCaf header@>@M==@{@-
void markCaf(void)@-
@}

@$@<markCaf routine@>==@{@-
@<markCaf header@>
{
    while (newCaf != GcEnd) {
        GcConst cptr = newCaf;
        Int size = cptr->sizeArity;
        Int i;
        size = FSTHW(size);
        newCaf = cptr->next;
        cptr->next = oldCaf;
        oldCaf = cptr;

        @<Mark the first word of the CAF@>
        @<Mark the constituents of the CAF@>
    }
}
@}

If the first word is an indirection we mark it.

FIXME: why is the first word processed specially?

@$@<Mark the first word of the CAF@>==@{@-
{
    NodePtr *nptr = &cptr->ptr[0];
    if (GET_TAG(nptr) == IND_TAG)
        mark(nptr);
}
@}

Next, we skip over the first word of the CAF node and any extra
information in the node and process rest of the contents one by one.
@{VAP@}s just get added to the CAF list for processing themselves since
they have no remaining arguments.  Indirection nodes we just follow and
mark whatever they point to.

FIXME: constructor applications are errors why?

@$@<Mark the constituents of the CAF@>==@{@-
i = EXTRA+1;
size += EXTRA+1;
for ( ; i < size; i++) {
    NodePtr nptr = cptr->ptr[i];
    switch (EXT_TAG(nptr)) {
        case VAP_TAG0:
        case VAP_TAG1: {
                Cinfo cinfo = EXT_CINFO(nptr);
                addCaf(CINFO_FINFO(cinfo));
            }
            break;

        case IND_TAG:
            mark(&cptr->ptr[i]);
            break;

        case CON_TAG:
            @<Complain about CON_TAG@>
    }
}
@}

@$@<Complain about CON_TAG@>==@{@-
ERROR_OUT("CON_TAG in markCaf(1) cptr = %p ", cptr);
ERROR_OUT("sizeArity = %08x ", cptr->sizeArity);
ERROR_OUT("i = %2ld %p:%p\n", i, &cptr->ptr[i], nptr);
EXITPROG(-1);
@}

@B@<Marking nodes@>

The @{mark@} routine is responsible for traversing graph structures and
actually marking nodes.  The argument is a pointer to the @{NodePtr@} that
must be checked.  This reference passing is needed so that we can update
the node in some cases.

The marking algorithm starts with the node passed to it and operates as a
state machine with three states: Inspect, Push and Next.  When in the
Inspection state the machine looks at a node and processes it.  The Push
state records an encountered node on a stack for later inspection.  The
Next state moves the machine to inspect the next node or terminates the
marking phase if there are no more nodes.

@$@<mark header@>@M==@{@-
void mark(NodePtr *inode)@-
@}

@$@<mark routine@>==@{@-
@<mark header@>
{
    NodePtr node = *inode;
    UInt tag;

    @<Node stack@>

    @<Mark debug@>@("mark %lx:", (UInt)node@)
    @<Initialise node stack@>

InspectNode:
    @<Mark debug@>@("InspectNode %lx:", (UInt)node@)
    @<Trap nodes outside the heap@>
    @<Get the node tag@>
    @<Inspect a node outside heap and stack area@>
    @<Short-circuit marked nodes@>
    @<Inspect a regular node@>

PushNode:
    @<Mark debug@>@("PushNode %lx:", (UInt)node@)
    @<Push a node@>

NextNode:
    @<Mark debug@>@("NextNode %lx:", (UInt)node@)
    @<Go to next node@>
}
@}

@$@<Mark debug@>@(@1@)@M==@{@-
#ifdef DEBUG_MARK
ERROR_OUT(@1);
FLUSH_ERR;
#endif
@}

@C@<Pushing nodes@>

@{pptr@} is the top of the stack of pointers to nodes that still need to
be processed.  It starts out just containing a sentinel NULL node that is
used to terminate the process.  The sentinel is stored in the second
lowest word in the heap area.

FIXME: is it really a stack?  or just reversed pointers on the way down?

FIXME: should hpLowLimit[1] be hpLowLimit[1+EXTRA]?  See the initialisation
in collector.  Are these bits related?

@$@<Node stack@>==@{@-
NodePtr pptr, newpptr;
@}

@$@<Initialise node stack@>==@{@-
pptr = &hpLowLimit[1];
hpLowLimit[1] = 0;
@}

Pushing a node is just a matter of saving the new node, reversing the
pointer to it to point to the (reversed) chain of pointers we are
currently following and updating the chain head to be the new node
pointer. This is undone in the ``go to next node'' step described below.

@$@<Push a node@>==@{@-
node = (NodePtr)*newpptr;
*newpptr = (Node)pptr;
pptr = newpptr;
goto InspectNode;
@}

@C@<Inspecting nodes@>

We inspect nodes by first trapping nodes that somehow fall completely
outside the memory allocation area.

@$@<Trap nodes outside the heap@>==@{@-
if (node > hpEnd) {
    ERROR_OUT("InspectNode %lx > hpEnd %lx\n", (UInt)node, (UInt)hpEnd);
    EXITPROG(-1);
}
@}

Then we remove indirections and get the tag of the node actually addressed.

@$@<Get the node tag@>==@{@-
IND_REMOVE(node);
tag = EXT_LARGETAG(*node);
@}

Then we deal with nodes that lie outside the heap and stack areas.
@{VAP@}s in this region are added to the CAF list for later processing.

FIXME: how can any useful nodes lie OUTSIDE the heap and stack area?  This
would also seem to include the bit table which is presumably not referenced
as nodes.  In short, when will this code ever be used?

@$@<Inspect a node outside heap and stack area@>==@{@-
if (OUTSIDE(node)) {
    if (tag & VAP_TAG) {
        Cinfo cinfo;
        @<Mark debug@>@("VAP(0):"@)
        cinfo = GET_CINFO(node);
        addCaf(CINFO_FINFO(cinfo));
    }
    goto NextNode;
}
@}

At this point if the node has already been marked then we're done so go
to the next one.

@$@<Short-circuit marked nodes@>==@{@-
if (marked(node))
    goto NextNode;
@}

Then we process the different possibilities for an unmarked regular node.
The cases cover all of the possible node types with the exception of
@{IND_TAG@} since that should not occur since we removed indirections
above.

@$@<Inspect a regular node@>==@{@-
switch(tag) {

    @<Inspect VAP constructor applications@>
    @<Inspect CON constructor applications@>

    default:
        ERROR_OUT("Bad tag 0x%x in mark!\n", tag);
        EXITPROG(-1);
}
@}

VAP constructor applications are simply added to the CAF list.  The
arguments of the application are next to be considered.  Note that
@{newpptr@} is set to the address of the last argument (if there are any)
and we work our way backwards through them (see the description of going
to the next node in the next section).

FIXME: The CON_CDATA cases should not be here but some of the tests fail
when marking nodes with these tags.  Not sure where they are coming from.
Remove CON_CDATA from graph.fwi too when resolved.

@$@<Inspect VAP constructor applications@>==@{@-
case CON_DATA | VAP_TAG0:
case CON_PTRS | VAP_TAG0:
case CON_CDATA | VAP_TAG0:
case CON_WORDS | VAP_TAG0:
case CON_DATA | VAP_TAG1:
case CON_PTRS | VAP_TAG1:
case CON_CDATA | VAP_TAG1:
case CON_WORDS | VAP_TAG1: {
        Cinfo cinfo = GET_CINFO(node);
        Int size = (Int)CINFO_SIZE(cinfo);
        Finfo finfo = CINFO_FINFO(cinfo);

        @<Mark debug@>@("VAP/CAP:"@)

        @<Perform Wadler optimisation@>

        addCaf(finfo);
        if (size) {
            newpptr = node+size+EXTRA;
            goto PushNode;
        }
    }
    goto NextNode;
@}

FIXME: need to add in the Wadler optimisation stuff (move into own
section?).

@$@<Perform Wadler optimisation@>==@{@-
@}

@{CON_DATA@} and @{CON_CDATA@} nodes contain pointers followed by
integers.  As above, in this and the next case, start with the last
argument and work backwards.  The only difference between the two
is that @{CON_CDATA@} is used for foreign objects so we have to make
sure to mark them as well.

@$@<Inspect CON constructor applications@>+=@{@-
case CON_DATA | CON_TAG: {
        Coninfo coninfo = GET_CONINFO(node);
        Int psize  = (Int)CONINFO_PSIZE(coninfo);
        @<Mark debug@>@("CON_DATA:"@)
        if (psize) {
            newpptr = node+psize+EXTRA;
            @<Mark debug@>@("node = %lx newpptr = %lx:", (UInt)node,
                            (UInt)newpptr@)
            goto PushNode;
        }
    }
    goto NextNode;

case CON_CDATA | CON_TAG: {
        Coninfo coninfo = GET_CONINFO(node);
        Int psize  = (Int)CONINFO_PSIZE(coninfo);
        @<Mark debug@>@("CON_CDATA:"@)
        markForeignObj((ForeignObj *)*(node+psize+1+EXTRA));
        if (psize) {
            newpptr = node+psize+EXTRA;
            @<Mark debug@>@("node = %lx newpptr = %lx:", (UInt)node,
                            (UInt)newpptr@)
            goto PushNode;
        }
    }
    goto NextNode;
@}

A @{CON_PTRS@} node just contains pointers.

@$@<Inspect CON constructor applications@>+=@{@-
case CON_PTRS | CON_TAG: {
        Coninfo coninfo = GET_CONINFO(node);
        Int psize  = (Int)CONINFO_LARGESIZEU(coninfo);
        @<Mark debug@>@("CON_PTRS: psize = %d:", psize@)
        if (psize) {
            newpptr = node+psize+EXTRA;
            @<Mark debug@>@("node = %lx newpptr = %lx:", (UInt)node,
                            (UInt)newpptr@)
            goto PushNode;
        }
    }
    goto NextNode;
@}

Finally, a @{CON_WORDS@} node just contains integers which don't need to
be inspected further.  However, as an optimisation we check to see if it's
a single integer within the range of the @{ints@} table.  If it is, then
unmark the argument node so it will get collected and replace it with a
reference to the single instance of the integer in the table.

FIXME:  It would seem that char nodes will be refs to the ints table.
There is no difference in the values so is the chars table really
needed?

FIXME: the limits of the table should really be constants (or macros)
exported by newtables.fwi rather than hard-coded here.

@$@<Inspect CON constructor applications@>+=@{@-
case CON_WORDS | CON_TAG: {
        Int i;
        @<Mark debug@>@("CON_WORDS:"@)
        if (*node == CONSTRW(1,0) && (i=node[EXTRA+1]) >= -10 && i <= 255) {
            unmarked(node);
            node = GET_INT(i);
        }
    }
    goto NextNode;
@}

@C@<Going to the next node@>

First, save a pointer to the rest of the chain of (reversed) pointers in
@{tmp@}.  Then update the top pointer on the stack to point to the node
just processed (in case it has changed such as in the known integer case).
In effect, this reverses the pointer back to point to the node rather than
back up the chain.

Then go backwards one word.  If there are more sibling nodes of the node
just processed, then this will get the next one which will be unmarked.
The final @{else@} branch just sets @{node@} to the new sibling so it is
processed next and resets @{pptr@} to the stack uppon entry (i.e., no
change to the stack).

The first branch deals with the case when we have exhausted all of the
siblings at the current level.  If the top of the stack points to a node
formed by a zero word then it has reached the @{hpLowLimit@} zero sentinel
and we are done.  Set the argument reference to the new node in case there
has been an update and return the node.

If we haven't reached the sentinel then we have finished processing the
node containing the siblings just processed and there are more nodes on
the stack to inspect.  We reconstruct a pointer to that parent node by
moving backwards over the extra information from the leftmost field.
Since it has already been processed we just pop the stack and fetch the
next node recursively.

@$@<Go to next node@>==@{@-
{
    Node tmp = *pptr;
    *pptr-- = (Node)node;

    if (ifmarked(pptr)) {
        @<Mark debug@>@("PopNode %lx:", (UInt) node@)
        if (tmp) {
            node = -EXTRA + (NodePtr)pptr;
            pptr = (NodePtr)tmp;
            goto NextNode;
        } else {
            *inode = node;
            @<Mark debug@>@("Return %lx:", (UInt) node@)
            return;
        }
    } else {
        node = (NodePtr)*pptr;
        *pptr = tmp;
        goto InspectNode;
    }
}
@}
