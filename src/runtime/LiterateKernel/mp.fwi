@A@<Multiple-precision arithmetic support@>

This module encapsulates defines interfaces to the multiple precision
integer arithmetic support in the @{Integer@} part of the runtime.

FIXME: This stuff should probably be defined in the @{Integer@}
subdirectory.

@$@<Multiple precision integer interface@>==@{@-
@<MP_INT type@>
@<Limb types@>
@<Multiple-precision operations@>
@<Helper functions@>
@}

@B@<Number representation@>

A multiple precision integer is represented by an @{MP_INT@} structure.
@{abs(SIZE)@} is the number of limbs the @{d@} field points to.  If
@{SIZE@} is negative this is a negative number.

FIXME: The above comes from the original comments.  I presume @{SIZE@}
refers to the @{sizeTag@} field.

@$@<MP_INT type@>==@{@-
typedef struct
{
  Int sizeTag;
  UInt d[1];
} __MP_INT;

#define MP_INT __MP_INT
@}

The following types define the representation of limbs and associated
values.

@$@<Limb types@>==@{@-
typedef unsigned long int mp_limb;
typedef long int mp_limb_signed;
typedef mp_limb *mp_ptr;
typedef mp_limb *mp_srcptr;
typedef long int mp_size;
@}

@B@<Functions@>

The following functions provide operations on multiple precision integer
values and are defined in the @{Integer@} module.  The general interface
pattern is @{first free = fun(dst,src1,src2)@}.

FIXME: what does the @{first free@} mean?

@$@<Multiple-precision operations@>==@{@-
NodePtr mpz_add(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_add_need(MP_INT *,MP_INT *);
NodePtr mpz_sub(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_sub_need(MP_INT *,MP_INT *);
NodePtr mpz_div(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_div_need(MP_INT *,MP_INT *);
NodePtr mpz_mul(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_mul_need(MP_INT *,MP_INT *);
NodePtr mpz_mod(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_mod_need(MP_INT *,MP_INT *);
NodePtr mpz_and(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_and_need(MP_INT *,MP_INT *);
NodePtr mpz_or(MP_INT *,MP_INT *,MP_INT *);
Int     mpz_or_need(MP_INT *,MP_INT *);

NodePtr mpz_abs(MP_INT *,MP_INT *);
Int     mpz_abs_need(MP_INT *);
NodePtr mpz_sgn(MP_INT *,MP_INT *);
Int     mpz_sgn_need(MP_INT *);
NodePtr mpz_neg(MP_INT *,MP_INT *);
Int     mpz_neg_need(MP_INT *);

int mpz_le(MP_INT *,MP_INT *);  /* bool = fun(src1,src2) */
int mpz_eq(MP_INT *,MP_INT *);
@}

These functions are internal helper functions used internally in the
implementation of the above operations.

FIXME: Do these really need to be in the runtime interface or are they
local to the @{Integer@} module?

@$@<Helper functions@>==@{@-
mp_size _mpn_add(mp_ptr sum_ptr
                ,mp_srcptr add1_ptr, mp_size add1_size
                ,mp_srcptr add2_ptr, mp_size add2_size);

mp_size _mpn_sub (mp_ptr dif_ptr
                 ,mp_srcptr min_ptr, mp_size min_size
                ,mp_srcptr sub_ptr, mp_size sub_size);

mp_size _mpn_mul (mp_ptr prodp
                 ,mp_srcptr up, mp_size usize
                 ,mp_srcptr vp, mp_size vsize);

mp_size _mpn_div (mp_ptr quot_ptr
                 ,mp_ptr num_ptr, mp_size num_size
                 ,mp_srcptr den_ptr, mp_size den_size);

int _mpn_cmp (mp_srcptr op1_ptr, mp_size op1_size
             ,mp_srcptr op2_ptr, mp_size op2_size);

mp_limb _mpn_lshift (mp_ptr wp
                    ,mp_srcptr up, mp_size usize
                    ,unsigned long int cnt);

mp_size _mpn_rshift (mp_ptr wp
                    ,mp_srcptr up, mp_size usize
                    ,unsigned long int cnt);
@}
