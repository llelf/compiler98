@A@<Stable pointers@>

This section provides stable pointers so that heap addresses can be
referred to by references that never change even in the presence of
garbage collection moving things around in the heap.

@O@<stableptr.c@>==@{@-
#include "runtime.h"
#include "mark.h"
#include "stableptr.h"

@<Stable pointer table@>

@<mapStablePtrs routine@>
@<Mark and flip routines@>

@<stableInit routine@>
@<makeStablePtr routine@>
@<freeStablePtr routine@>
@<derefStablePtr routine@>
@<copyStablePtr routine@>
@}

@O@<stableptr.h@>==@{@-
#ifndef _STABLEPTR_H
#define _STABLEPTR_H

@<Stable pointer type@>

extern @<stableInit header@>;
extern @<makeStablePtr header@>;
extern @<freeStablePtr header@>;
extern @<derefStablePtr header@>;
extern @<copyStablePtr header@>;

#endif
@}

@B@<Stable pointer table@>

Stable pointers pretend to be arbitrary pointers even though they are
actually just table indexes.

@$@<Stable pointer type@>==@{@-
typedef void* StablePtr;
@}

@{StableTable@} is a table of the node pointers that are being represented.
The table starts with @{STABLE_ALLOCSIZE@} entries.  @{StableFree@} records
the current number of free entries and @{StableRefNr@} is used to record
the next free entry during allocation.

@$@<Stable pointer table@>==@{@-
static long STABLE_ALLOCSIZE = 1024;

static NodePtr *StableTable;

static long StableFree;
static long StableRefNr;
@}

@B@<Initialising the table@>

The table is initialised in the obvious way.  We also register a user-level
garbage collector so the references in the table are included in collections.

@$@<Initialise stable pointers@>==@{@-
stableInit();
@}

@$@<stableInit header@>@M==@{@-
void stableInit()@-
@}

@$@<stableInit routine@>==@{@-
@<stableInit header@>
{
    long i;

    if (!(StableTable = (NodePtr*)malloc(STABLE_ALLOCSIZE*sizeof(NodePtr*)))) {
         ERROR_OUT("Couldn't allocate stable pointer table.\n");
         EXITPROG(1);
    }
    for (i = 0; i < STABLE_ALLOCSIZE; i++)
        StableTable[i] = (NodePtr)0;
    StableFree = STABLE_ALLOCSIZE - 1;
    StableRefNr = 1;
    add_user_gc(stableMark, stableFlip);
}
@}

@B@<Garbage collection@>

The mark and flip routines for garbage collection just apply the regular
@{mark@} and @{flip@} on each valid pointer in the table.  They use a
helper function that maps a function over the table.

@$@<mapStablePtrs routine@>==@{@-
void mapStablePtrs(void (*f)(NodePtr*))
{
  long i;
  for(i=0; i < STABLE_ALLOCSIZE; i++) {
    if (StableTable[i]) {
      f(&StableTable[i]);
    }
  }    
}
@}

@$@<Mark and flip routines@>==@{@-
void stableMark()
{
    mapStablePtrs(mark);
}

void stableFlip()
{
    mapStablePtrs(flip);
}
@}

@B@<Making stable pointers@>

Whenever we get a stable ptr, it is given a reference number and placed in
the table by @{makeStablePtr@}.  For convenience of testing, we never use
the zero index in the table.  If the table fills up we realloc it to be
twice and big and initialise the new bit.  To find the spot for the new
entry we scan the table (with wrap-around).  Once found, the provide node
pointer is inserted and the index is returned as the stable pointer.

@$@<makeStablePtr header@>@M==@{@-
StablePtr makeStablePtr(unsigned long *lp)@-
@}

@$@<makeStablePtr routine@>==@{@-
@<makeStablePtr header@>
{
    NodePtr np = (NodePtr)lp;
    if (--StableFree == 0) {
        long i = STABLE_ALLOCSIZE;
        StableFree += STABLE_ALLOCSIZE;
        STABLE_ALLOCSIZE *= 2;
        if (!(StableTable =
                (NodePtr*)REALLOC((void*)StableTable,
                                  STABLE_ALLOCSIZE*sizeof(NodePtr*)))) {
            ERROR_OUT("Couldn't increase size of stable pointer table.\n");
            EXITPROG(1);
        }
        for (; i<STABLE_ALLOCSIZE; i++)
            StableTable[i] = (NodePtr)0;
    }
    while (StableTable[StableRefNr]) {
        if (++StableRefNr == STABLE_ALLOCSIZE)
            StableRefNr = 1;
    }
    StableTable[StableRefNr] = np;
    return (StablePtr)StableRefNr;
}
@}

@B@<Freeing stable pointers@>

@$@<freeStablePtr header@>@M==@{@-
void freeStablePtr(StablePtr i)@-
@}

@$@<freeStablePtr routine@>==@{@-
@<freeStablePtr header@>
{
    StableTable[(long)i] = (NodePtr)0;
    StableFree++;
}
@}

@B@<Dereferencing stable pointers@>

Nodes are looked up in the table using @{derefStablePtr@}
If it returns zero, the node is not in the table.

@$@<derefStablePtr header@>@M==@{@-
unsigned long *derefStablePtr(StablePtr ref)@-
@}

@$@<derefStablePtr routine@>==@{@-
@<derefStablePtr header@>
{
    return (unsigned long *)StableTable[(long)ref];
}
@}

@B@<Copying stable pointers@>

Finally, a stable pointer can be copied to another using @{copyStablePtr@}.

@$@<copyStablePtr header@>@M==@{@-
void copyStablePtr(StablePtr i, StablePtr v)@-
@}

@$@<copyStablePtr routine@>==@{
@<copyStablePtr header@>
{
    StableTable[(long)i] = StableTable[(long)v];
}
@}
