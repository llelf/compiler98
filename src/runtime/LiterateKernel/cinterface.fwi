@A@<C function interface@>

This section describes how native C functions are called by the runtime.
Many of the builtin Haskell operations are implemented this way.  See the
@{runtime/Builtin@} directory.

@O@<cinterface.h@>==@{@-
#ifndef _CINTERFACE_H
#define _CINTERFACE_H

@<File warning@>

#include "node.h"
#include "mutlib.h"

@<CALL_C macro@>
@<C function macros@>
@<C_CODE macro@>
@<C collection macros@>

@<Primitive type@>

extern @<evalExport header@>;

#endif
@}

@O@<ffiexport.c@>==@{@-
@<File warning@>

#include "haskell2c.h"
#include "newmacros.h"

@<evalExport routine@>
@}

@B@<Primitive functions@>

Primitives are implemented as functions that take a node pointer representing
arguments and return nothing (via C).  The argument is always a @{VAP@} node.

FIXME: the documentation in the old cinterface.h says: "We provide a very
primitive interface to C.  The C function is called with four arguments:
1) a status int, 0 first time, 2)  a pointer to the redex (always a
@{VAP@} node), 3) a pointer to the heap pointer, and 4) a pointer to the
stack pointer."  However, this is clearly not what the macros do so I
presume this comment is out of date.  Delete it?

@$@<Primitive type@>==@{@-
typedef void (*Primitive)(NodePtr);
@}

@B@<Calling a primitive function@>

The macro @{CALL_C@} is used to call a primitive function.  It saves the
cached mutator state back into the global variables so that they are
accessible to the C function.  Then the current @{vapptr@} is passed. The
function must push one value on the stack, and correctly update both the
heap and the stack pointers, before returning.  On return, the local cache
of the mutator state is re-established and the @{vapptr@} is set to the
return value.

@$@<CALL_C macro@>==@{@-
#define CALL_C(fun) \
    Hp = hp; Sp = sp; Fp = fp; Ip = ip; \
    (*fun)(vapptr); \
    hp = Hp; sp = Sp; fp = Fp; ip = Ip; vapptr = fp[2];
@}

@B@<Macros for declaring primitive functions@>

The following macros can be used to declare primitive functions, saving
repetition of common aspects.  @{C_HEADER@} provides a standard header.

FIXME: C_HEADER would indicate that the function takes no argument which
contradicts the Primitive prototype above.

@$@<C function macros@>+=@{@-
#define C_HEADER(fun)  void fun(void)
@}

@{C_GETARG1@} and @{C_ZAPARG1@} provide access to and zapping of arguments.

@$@<C function macros@>+=@{@-
#define _ivapptr   (Fp[2])
#define C_GETARG1(n)   (NodePtr)_ivapptr[n+EXTRA]
#define C_ZAPARG1(n)   _ivapptr[EXTRA + n] = (Node)ZAP_ARG_NODE
@}

@{C_RETURN@} pushes a return value and returns from the primitive.

@$@<C function macros@>+=@{@-
#define C_RETURN(x)    *--Sp = (x); return
@}

@{C_ALLOC@}, @{C_HP@} and @{C_ADDHP@} provide the ability to allocate
space on the Haskell heap.  @{C_ALLOC@} is intended to be used as @{foo =
C_ALLOC(n)@} so that it allocates and returns the location of the
allocated cell at the same time.  @{C_HP@} and @{C_ADDHP@} just return and
update the heap pointer, respectively.

@$@<C function macros@>+=@{@-
#define C_ALLOC(n)     Hp; Hp += n
#define C_HP           Hp
#define C_ADDHP(n)     Hp += n
@}

@{C_PUSH@} and @{C_POP@} allow the Haskell stack to be manipulated.

@$@<C function macros@>+=@{@-
#define C_PUSH(n)      *--Sp = (n)
#define C_POP()        (*Sp++)
@}

Finally, @{C_EVALTOS@} can be used to recursively call the mutator to evaluate
a node.

@$@<C function macros@>+=@{@-
#define C_EVALTOS(x)   run(x);
@}

@B@<Garbage collection@>

If a primitive wants to allocate space on the heap it should use one of
the following macros to check that space is available and, if it isn't, to
trigger a garbage collection.

@{C_CHECK@} just checks to see that there is room to allocate the amount
of space given by its argument.  If not, @{C_GC@} is used to call the
collector. @{C_CHECK_STMT@} is the same except it allows an argument
statement to be executed after the collection is finished.

@$@<C collection macros@>+=@{@-
#define C_CHECK(c) \
    if (Hp + (c) + BUFFER > (NodePtr)Sp) { C_GC(c); }
#define C_CHECK_STMT(c,stmt) \
    if (Hp + (c) + BUFFER > (NodePtr)Sp) { C_GC(c); stmt }
@}

FIXME: move these to the collector since that is the module that lays out
the memory space?

@{C_GC@} actually triggers the collection.  It first saves the current
state and sets it up to return to that point when the collection is over.
@{C_CODE@} is the set up to terminate the mutator using
@{Prelude.primLeave@}.

@$@<C_CODE macro@>==@{@-
#define C_CODE ((Code)FN_Prelude_46primLeave)
@}

FIXME: not sure exactly what this is doing.

@$@<C collection macros@>+=@{@-
#define C_GC(c) \
     *--Sp = (NodePtr)Fp; *--Sp=(NodePtr)C_CODE;Fp=Sp; \
     Hp = callGc((c),Hp,Sp,Fp);     \
     Sp++;Fp=(NodePtr*)*Sp++;IND_REMOVE(_ivapptr);
@}

@B@<Evaluation of a C routine@>

FIXME: explain.

@$@<evalExport header@>@M==@{@-
NodePtr evalExport(NodePtr x)@-
@}

@$@<evalExport routine@>==@{@-
@<evalExport header@>
{
  CodePtr IP = Ip;
  StablePtr p = makeStablePtr(x);
  Fp = Sp;
  C_PUSH(x);
  C_EVALTOS(x);
  C_POP();
  Ip = IP;
  x = derefStablePtr(p);
  freeStablePtr(p);
  return x;
}
@}
