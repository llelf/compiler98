@A@<Bytecode instructions@>

This section defines the bytecode instructions supported by this runtime.

These files define the bytecode instructions emitted by the compiler.  The
actual list of instructions is in @{newbytecode.h@} so we can reuse the
list in different situations.

@O@<bytecode.h@>==@{@-
#ifndef _BYTECODE_H
#define _BYTECODE_H

@<File warning@>

#include "runtime.h"

@<Instruction enumeration@>

#ifdef DEBUG
extern @<prByteIns header@>;
#endif

#endif
@}

@O@<newbytecode.h@>==@{@-
#ifndef _NEWBYTECODE_H
#define _NEWBYTECODE_H

@<File warning@>

@<Bytecode instruction list@>

#endif
@}

@O@<bytecode.c@>==@{@-
@<File warning@>

#include "runtime.h"

#ifdef DEBUG

#include "bytecode.h"
#include "cinterface.h"

@<Instruction names@>

@<prByteIns routine@>

#endif
@}

@B@<Bytecode enumeration@>

The @{Instr_t@} enumeration has one entry per instruction.  We define the
bytecodes as an enumeration type (rather than just a standard sequence of
#defines) in order to take advantage of the gcc compiler extension for
computed goto labels, which wins us about 25% speed increase in the
mutator.

@$@<Instruction enumeration@>==@{@-
#include "newbytecode.h"

#define ins(x) x
typedef enum { INSTRUCTION_LIST } Instr_t;
#undef ins
@}

@B@<Bytecode instruction list@>

The list of instructions and the actual enumeration are separated into two
files because there is an older (obsolete) output format that can be
generated by the nhc98 compiler.  The obsolete format expects the bytecode
to be available as ordinary #defines, not as an enum.  In order to keep
the obsolete format in synch with the new format, there is a script which
can process the file you are reading now, to generate the older format.
See script/mangler.

@$@<Bytecode instruction list@>==@{@-
#define INSTRUCTION_LIST        \
 ins(DUMMY_FOR_ZERO),   \
\
 ins(NEEDHEAP_P1),      \
 ins(NEEDHEAP_P2),      \
 ins(JUMP),             \
 ins(JUMPFALSE),        \
 ins(NOP),              \
\
 ins(PUSH_CADR_N2),     \
 ins(PUSH_CADR_N1),     \
 ins(PUSH_CADR_P1),     \
 ins(PUSH_CADR_P2),     \
 ins(PUSH_CVAL_N2),     \
 ins(PUSH_CVAL_N1),     \
 ins(PUSH_CVAL_P1),     \
 ins(PUSH_CVAL_P2),     \
 ins(PUSH_INT_N2),      \
 ins(PUSH_INT_N1),      \
 ins(PUSH_INT_P1),      \
 ins(PUSH_INT_P2),      \
 ins(PUSH_ARG),         \
 ins(PUSH_P1),          \
 ins(PUSH_P2),          \
\
 ins(POP_P1),           \
 ins(POP_P2),           \
 ins(SLIDE_P1),         \
 ins(SLIDE_P2),         \
 ins(UNPACK),           \
\
 ins(APPLY),            \
 ins(EVAL),             \
\
 ins(RETURN),           \
 ins(RETURN_EVAL),      \
\
 ins(HEAP_CADR_N2),     \
 ins(HEAP_CADR_N1),     \
 ins(HEAP_CADR_P1),     \
 ins(HEAP_CADR_P2),     \
 ins(HEAP_CVAL_N2),     \
 ins(HEAP_CVAL_N1),     \
 ins(HEAP_CVAL_P1),     \
 ins(HEAP_CVAL_P2),     \
 ins(HEAP_INT_N2),      \
 ins(HEAP_INT_N1),      \
 ins(HEAP_INT_P1),      \
 ins(HEAP_INT_P2),      \
 ins(HEAP_ARG),         \
 ins(HEAP_ARG_ARG),     \
 ins(HEAP_ARG_ARG_RET_EVAL),    \
 ins(HEAP_P1),          \
 ins(HEAP_P2),          \
\
 ins(ADD_W),            \
 ins(ADD_F),            \
 ins(ADD_D),            \
 ins(SUB_W),            \
 ins(SUB_F),            \
 ins(SUB_D),            \
 ins(MUL_W),            \
 ins(MUL_F),            \
 ins(MUL_D),            \
 ins(ABS_W),            \
 ins(ABS_F),            \
 ins(ABS_D),            \
 ins(SIGNUM_W),         \
 ins(SIGNUM_F),         \
 ins(SIGNUM_D),         \
 ins(EXP_F),            \
 ins(EXP_D),            \
 ins(LOG_F),            \
 ins(LOG_D),            \
 ins(SQRT_F),           \
 ins(SQRT_D),           \
 ins(SIN_F),            \
 ins(SIN_D),            \
 ins(COS_F),            \
 ins(COS_D),            \
 ins(TAN_F),            \
 ins(TAN_D),            \
 ins(ASIN_F),           \
 ins(ASIN_D),           \
 ins(ACOS_F),           \
 ins(ACOS_D),           \
 ins(ATAN_F),           \
 ins(ATAN_D),           \
 ins(SLASH_F),          \
 ins(SLASH_D),          \
 ins(EQ_W),             \
 ins(EQ_F),             \
 ins(EQ_D),             \
 ins(NE_W),             \
 ins(NE_F),             \
 ins(NE_D),             \
 ins(LT_W),             \
 ins(LT_F),             \
 ins(LT_D),             \
 ins(LE_W),             \
 ins(LE_F),             \
 ins(LE_D),             \
 ins(GT_W),             \
 ins(GT_F),             \
 ins(GT_D),             \
 ins(GE_W),             \
 ins(GE_F),             \
 ins(GE_D),             \
 ins(NEG_W),            \
 ins(NEG_F),            \
 ins(NEG_D),            \
\
 ins(QUOT),             \
 ins(REM),              \
 ins(AND),              \
 ins(OR),               \
 ins(NOT),              \
 ins(ORD),              \
 ins(CHR),              \
 ins(SEQ),              \
 ins(STRING),           \
\
 ins(PRIMITIVE),        \
 ins(PUSH_HEAP),        \
 ins(EXIT),             \
\
 ins(NEEDSTACK_P1),     \
 ins(NEEDSTACK_P2),     \
\
 ins(HEAP_OFF_N2),      \
 ins(HEAP_OFF_N1),      \
 ins(HEAP_OFF_P1),      \
 ins(HEAP_OFF_P2),      \
\
 ins(HEAP_CREATE),      \
 ins(HEAP_SPACE),       \
\
 ins(SELECTOR_EVAL),    \
 ins(SELECT),           \
\
 ins(ZAP_ARG),          \
 ins(ZAP_STACK_P1),     \
 ins(ZAP_STACK_P2),     \
\
 ins(NEEDHEAP_I32),     \
 ins(NEEDSTACK_I16),    \
\
 ins(PUSH_I1),          \
 ins(POP_I1),           \
\
 ins(PUSH_ARG_I1),      \
 ins(PUSH_ARG_I2),      \
 ins(PUSH_ARG_I3),      \
\
 ins(ZAP_ARG_I1),       \
 ins(ZAP_ARG_I2),       \
 ins(ZAP_ARG_I3),       \
\
 ins(HEAP_CVAL_I3),     \
 ins(HEAP_CVAL_I4),     \
 ins(HEAP_CVAL_I5),     \
\
 ins(HEAP_CVAL_IN3),    \
\
 ins(HEAP_I1),          \
 ins(HEAP_I2),          \
\
 ins(HPUTC),            \
 ins(HGETC),            \
 ins(HGETS),            \
\
 ins(PUSH_CHAR_N1),     \
 ins(PUSH_CHAR_P1),     \
 ins(HEAP_CHAR_N1),     \
 ins(HEAP_CHAR_P1),     \
\
 ins(TABLESWITCH),      \
 ins(LOOKUPSWITCH),     \
 ins(MKIORETURN),       \
\
 ins(PUSH_ZAP_ARG_I1),  \
 ins(PUSH_ZAP_ARG_I2),  \
 ins(PUSH_ZAP_ARG_I3),  \
 ins(PUSH_ZAP_ARG),     \
\
 ins(ENDCODE),          \
\
 ins(POW_F),            \
 ins(POW_D)

#define UNUSED_INSTRUCTIONS     \
 Case(DUMMY_FOR_ZERO):  \
 Case(SEQ):             \
 Case(NOT):             \
 Case(OR):              \
 Case(AND):             \
 Case(HEAP_INT_P2):     \
 Case(HEAP_INT_N2):     \
 Case(PUSH_INT_P2):     \
 Case(PUSH_INT_N2):
@}

@B@<Debugging support@>

For debugging it is useful to be able to print instruction names.  We'd
rather not have to manually update a list of the names that corresponds
to the instruction set enumeration.  So, we define it as follows.

@$@<Instruction names@>==@{@-
#include "newbytecode.h"

#define ins(x) #x
static char *instr_names[] = { INSTRUCTION_LIST };
#undef ins
@}

@$@<prByteIns header@>@M==@{@-
void prByteIns (CodePtr ip)@-
@}

@$@<prByteIns routine@>==@{@-
@<prByteIns header@>
{
    static int count = 0;

    ERROR_OUT("%6d : ip = %4x %s", count, ip, instr_names[*ip]);
    count++;
    switch (*ip) {
        case ZAP_ARG_I1: case ZAP_ARG_I2: case ZAP_ARG_I3: case NEEDHEAP_I32:
        case NEEDSTACK_I16: case NOP: case PUSH_ARG_I1: case PUSH_ARG_I2:
        case PUSH_ARG_I3: case PUSH_I1: case POP_I1: case SELECTOR_EVAL:
        case EVAL: case RETURN: case RETURN_EVAL: case HEAP_CREATE:
        case HEAP_SPACE: case HEAP_CVAL_IN3: case HEAP_CVAL_I3:
        case HEAP_CVAL_I4: case HEAP_CVAL_I5: case HEAP_I1: case HEAP_I2:
        case ADD_W: case ADD_F: case ADD_D: case SUB_W: case SUB_F:
        case SUB_D: case MUL_W: case MUL_F: case MUL_D: case ABS_W: case ABS_F:
        case ABS_D: case SIGNUM_W: case SIGNUM_F: case SIGNUM_D: case EXP_F:
        case EXP_D: case POW_F: case POW_D: case LOG_F: case LOG_D:
        case SQRT_F: case SQRT_D: case SIN_F: case SIN_D: case COS_F:
        case COS_D: case TAN_F: case TAN_D: case ASIN_F: case ASIN_D:
        case ACOS_F: case ACOS_D: case ATAN_F: case ATAN_D: case SLASH_F:
        case SLASH_D: case EQ_W: case EQ_F: case EQ_D: case NE_W: case NE_F:
        case NE_D: case LT_W: case LT_F: case LT_D: case LE_W: case LE_F:
        case LE_D: case GT_W: case GT_F: case GT_D: case GE_W: case GE_F:
        case GE_D: case NEG_W: case NEG_F: case NEG_D: case QUOT: case REM:
        case AND: case OR: case NOT: case ORD: case CHR: case SEQ:
        case STRING: case HGETS: case HGETC: case HPUTC: case EXIT:
        case MKIORETURN: case PUSH_HEAP: case ENDCODE: case PUSH_ZAP_ARG_I1:
        case PUSH_ZAP_ARG_I2: case PUSH_ZAP_ARG_I3: case TABLESWITCH:
        case LOOKUPSWITCH:
            break;

        case ZAP_ARG: case ZAP_STACK_P1: case NEEDHEAP_P1: case NEEDSTACK_P1:
        case PUSH_CADR_N1: case PUSH_CADR_P1: case PUSH_CVAL_N1:
        case PUSH_CVAL_P1: case PUSH_INT_N1: case PUSH_INT_P1: case PUSH_ARG:
        case PUSH_P1: case POP_P1: case SLIDE_P1: case UNPACK: case SELECT:
        case APPLY: case HEAP_OFF_N1: case HEAP_OFF_P1: case HEAP_CADR_N1:
        case HEAP_CADR_P1: case HEAP_CVAL_N1: case HEAP_CVAL_P1:
        case HEAP_INT_N1: case HEAP_INT_P1: case HEAP_ARG: case HEAP_P1:
        case HEAP_CHAR_N1: case HEAP_CHAR_P1: case PUSH_CHAR_N1:
        case PUSH_CHAR_P1: case PUSH_ZAP_ARG:
            ERROR_OUT(" %d", ip[1]);
            break;

        case ZAP_STACK_P2: case NEEDHEAP_P2: case NEEDSTACK_P2:
        case PUSH_CADR_N2: case PUSH_CADR_P2: case PUSH_CVAL_N2:
        case PUSH_CVAL_P2: case PUSH_INT_N2: case PUSH_INT_P2: case PUSH_P2:
        case POP_P2: case SLIDE_P2: case HEAP_OFF_N2: case HEAP_OFF_P2:
        case HEAP_CADR_N2: case HEAP_CADR_P2: case HEAP_CVAL_N2:
        case HEAP_CVAL_P2: case HEAP_INT_N2: case HEAP_INT_P2: case HEAP_P2:
        case HEAP_ARG_ARG: case HEAP_ARG_ARG_RET_EVAL:
            ERROR_OUT(" %d (%d:%d)", (ip[2]<<8)+ip[1], ip[1], ip[2]);
            break;

        case JUMP: case JUMPFALSE:
            ERROR_OUT(" %4x (%d:%d)",ip+1+(ip[2]<<8)+ip[1],ip[1],ip[2]);
            break;

        case PRIMITIVE:
            ip = (CodePtr) ALIGNPTR((ip+1));
            ERROR_OUT(" %4x",*(Primitive *)ip);
            break;

        default:
            ERROR_OUT("\nUnknown instruction %s (%d) at %4x",
                      instr_names[*ip], *ip, ip);
    }
    ERROR_OUT("\n");
    FLUSH_ERR;
}
@}
