@A@<Garbage Collector@>

This section encapsulates the nhc garbage collector except for the marking
phase which is described next.

@O@<collector.c@>==@{@-
@<File warning@>

#include <stdlib.h>
#include "node.h"
#include "mark.h"

@<Extra space in nodes for collector@>

@<Memory area state@>
@<Stack start@>
@<Collector timer@>
@<Statistical information@>
@<Logging setting@>
@<User GC list@>

#ifdef DEBUG
@<prMemoryLayout routine@>
@<prHeapStack routine@>
#endif

@<flip routine@>
@<nhc_update routine@>

@<clearCaf routine@>
@<flipCaf routine@>
@<flipStack routine@>
@<flipHeap routine@>
@<moveHeap routine@>

@<initGc routine@>
@<callGc routine@>
@<finishGc routine@>
@<add_user_gc routine@>

@}

@$@<Collector interface@>==@{
extern @<Collector timer@>
extern @<Logging setting@>

extern @<Stack start@>
extern @<Low heap limit@>
extern @<Heap end@>
extern @<Bit table@>

@<User GC types@>

extern @<initGc header@>;
extern @<callGc header@>;
extern @<finishGc header@>;
extern @<add_user_gc header@>;

@<Mark phase interface@>
extern @<flip header@>;

#ifdef DEBUG
extern @<prHeapStack header@>;
#endif
@}

@$@<Collector initialisation@>==@{@-
@<Clear collector timer@>
@}

@B@<Collector initialisation@>

Collector initialisation is performed by @{initGc@}.  It's given the
desired heap and stack sizes (@{hpSize@} and @{spSize@}) plus references
to the heap and stack pointers so they can be set (@{ihp@} and @{shp@}).

@$@<initGc header@>@M==@{@-
void initGc(Int hpSize, NodePtr *ihp, Int spSize, NodePtr **isp)@-
@}

@$@<initGc routine@>==@{@-
@<initGc header@>
{
    @<Compute size of memory area@>
    @<Check indirect tag@>
    @<Allocate memory area@>
    @<Assign bit table@>
    @<Assign stack area@>
    @<Check that there is room for heap@>
    @<Assign heap area@>
    @<Report memory layout@>
    @<Initialise heap@>
    @<Initialise statistical information@>
}
@}

The size of the memory area is given by @{totalSize@}.  Each word in that
area is represented by a bit in a table whose size is given by @{tableSize@}.

FIXME: What does this comment from the code mean? The last one is for end
of marked.

@$@<Compute size of memory area@>==@{@-
Int totalSize = hpSize + spSize;
Int tableSize = (totalSize + WORDSIZE) / (WORDSIZE + 1) + 1;
@}

This collector will only work if the indirect tag is zero so check it
first.  (FIXME: why is this the case?)

@$@<Check indirect tag@>==@{@-
if (IND_TAG) {
    ERROR_OUT("This garbage collector only works if IND_TAG == 0\n");
    EXITPROG(-1);
}
@}

The following diagram depicts the memory area and its various components
as represented by the various pointer variables maintained by the
collector.  The different variables are explained in the following.

@$@<Memory area variable layout@>@Z==@{@-
hpStart                                                          hpEnd
      hpBase
hpLowLimit                   hpLimit              bitTable
                hp               spEnd            spStart
@}

@$@<Memory area state@>==@{@-
static NodePtr hpStart, *spEnd;
static NodePtr hpLimit, hpBase;
@<Low heap limit@>
@<Heap end@>
@<Bit table@>
@}

Define these separately because they are needed by the mark phase so must
be exported.

@$@<Low heap limit@>@M==@{@-
NodePtr hpLowLimit;
@}

@$@<Heap end@>@M==@{@-
NodePtr hpEnd;
@}

@$@<Bit table@>@M==@{@-
NodePtr bitTable;
@}

@{spStart@} is used by the mark phase to help find the whole stack and by
the mutator to clear the stack, so it must be exported.

@$@<Stack start@>@M==@{@-
NodePtr *spStart;
@}

The memory area is allocated and the variables @{hpStart@} and @{hpEnd@}
point to its beginning and end, respectively.

@$@<Allocate memory area@>==@{@-
if (NULL == (hpStart = MALLOC((int)totalSize * sizeof(Node)))) {
    ERROR_OUT("not enough memory for heap and stack.\n");
    EXITPROG(-1);
}
hpEnd = hpStart + totalSize;
@}

The bit table is allocated at the high end of the memory area.

@$@<Assign bit table@>==@{@-
bitTable = hpEnd - tableSize;
@}

The runtime stack grows from the start of the bit table down towards the
heap area.

@$@<Assign stack area@>==@{@-
*isp = spStart = (NodePtr *) bitTable;
spEnd = spStart - spSize;
@}

The heap occupies the remainder of the memory area (the low end).  We
require that the heap section not reside in high memory.  This is because
we use the most significant bit as the zap bit so it is not available for
addressing.  Also, make sure that there is enough room after the stack has
been assigned space.

@$@<Check that there is room for heap@>==@{@-
if ((long)hpEnd>0x80000000) {
    ERROR_OUT("OS allocated a heap in high memory (>0x80000000)\n");
    ERROR_OUT("    which breaks this program's run-time system.\n");
    ERROR_OUT("  hpStart=0x%x, hpEnd=0x%x\n",hpStart,hpEnd);
    EXITPROG(-1);
}
if (spEnd <= (NodePtr*)hpStart) {
    ERROR_OUT("No space left for the heap!\n");
    EXITPROG(-1);
}
@}

@{hpLimit@} and @{hpLowLimit@} delimit the actual memory set aside for the
heap.  @{hpBase@} is the low limit after the most recent collection (same
as @{hpLowLimit@} at the beginning).

@$@<Assign heap area@>==@{@-
hpLimit = (NodePtr)spEnd - 128;
hpBase = hpLowLimit = hpStart;
*ihp = &hpLowLimit[GCEXTRA];
@}

When debugging the heap and stack, report the parameters of the memory
layout.

@$@<Report memory layout@>==@{@-
#ifdef DEBUG_HEAPSTACK
prMemoryLayout();
#endif
@}

The heap area is assigned with a small (false) security buffer between the
high end of the heap and the top of the stack area.  The heap for
allocation starts @{GCEXTRA@} words into the allocated space to leave room
for book-keeping information at the low end.

The book-keeping information consists of an area of size @{GCEXTRA@}
comprising two words for garbage collection plus whatever extra
information is needed by the rest of the runtime.

@$@<Extra space in nodes for collector@>==@{@-
#define GCEXTRA 2+EXTRA
@}

The header for the book-keeping information contains a cell containing a
single pointer pointing to the low limit of the heap space (including an
extra space used by extensions).

FIXME: exactly what is this pointer used for?  See also the stuff in mark
about using hpLowLimit[1] to store a zero word that is used to terminate
the marking process.

FIXME: why is CONSTR used here instead of CONSTRP since we just have a
single pointer?  No real difference I guess since there is only one of
them so the bigger size field is not needed.

@$@<Initialise heap@>==@{@-
hpLowLimit[0] = (Node)CONSTR(0,1,0);
hpLowLimit[1+EXTRA] = (Node)&hpLowLimit[0];
@}

@B@<Statistical information on collection@>

The collector maintains some information about the collections that it
performs: @{hpMove@} is the number of words moved by the collector (over
all collections), @{hpTotal@} is the number of heap words used (over all
collections), @{hpMaxSurvive@} is the maximum number of words that survive
immediately after a collection, and @{nogc@} is the number of collections
that have been performed.

@$@<Statistical information@>@M==@{@-
int64_t hpMoved, hpTotal;
Int hpMaxSurvive;
int nogc;
@}

@$@<Initialise statistical information@>==@{@-
hpMoved = hpTotal = (int64_t)0;
hpMaxSurvive = nogc = 0;
@}

@B@<Perform the collection@>

@{callGc@} is the main entry point for the collector.  It's given the size
of the allocation that caused the collection and the current heap, stack
and frame pointers.

The algorithm is essentially a mark-compact strategy implemented in three
phases: mark, flip and move.  The first phase marks live objects.  The
flip phase alters pointers to refer to the (soon to be) new location of
the data to which they refer.  Finally, the move phase compacts the heap
by moving all live objects down to the low end of the heap.

@$@<callGc header@>@M==@{@-
NodePtr callGc(Int size, NodePtr hp, NodePtr *sp, NodePtr *fp)@-
@}

@$@<callGc routine@>==@{@-
@<callGc header@>
{
    @<Stop runtime timer@>
    @<Start collection timer@>
    @<Update collection count@>

    @<Perform last safety check@>
    @<Log start of collection@>
    @<Increment total heap usage@>

    @<Clear foreign objects@>

    @<Mark the active nodes@>
    @<Flip the pointers@>
    @<Move the heap@>

    @<Increment heap moved and record survival@>
    @<Check that requested allocation fits@>

    @<Log result of collection@>

    @<Collect foreign objects@>

    @<Stop collection timer@>

    @<Clear the Caf list@>

    @<Start runtime timer@>

    @<Return new heap pointer@>
}
@}

@C@<Logging@>

The collector contains logging that can be enabled using the @{-B@}
runtime option (more options gives more information).  The variable
@{bellGc@} holds the number of times the @{-B@} option was specified.

FIXME: at the moment we have no argument processing so we initialise it
to something that shows none of our messages.  Fix this later.

@$@<Logging setting@>@M==@{@-
int bellGc;
@}

@$@<Log start of collection@>==@{@-
bellGc = 0;
if (bellGc) {
    FLUSH_OUT;
    ERROR_OUT("<GC %3d:Start>", nogc);
    FLUSH_ERR;
}
@}

@$@<Log result of collection@>==@{@-
if (bellGc) {
    FLUSH_OUT;
    ERROR_OUT("<GC %3d:%8d>\n", nogc, hp - &hpLowLimit[GCEXTRA]);
}
@}

This logging macro makes it easy to insert simple trace logging at various
points.

@$@<Log@>@(@1@)@M==@{@-
if (bellGc > 3) {
   ERROR_OUT(" @1");
   FLUSH_ERR;
}
@}

@C@<Collection timing@>

We use a timer to keep track of how long garbage collection takes.  This
only happens if there is some allocation required.

@$@<Collector timer@>@M==@{@-
timer gcTime;
@}

@$@<Clear collector timer@>+=@{@-
timerClear(&gcTime);
@}

@$@<Start collection timer@>==@{@-
if (size) timerStart(&gcTime);
@}

@$@<Stop collection timer@>==@{@-
if (size) timerStop(&gcTime);
@}

We also need to stop the runtime timer before collection starts and start
it again afterward so that the collection time is not included in its
count.

@$@<Start runtime timer@>==@{@-
if (size) timerStart(&runTime);
@}

@$@<Stop runtime timer@>==@{@-
if (size) timerStop(&runTime);
@}

@C@<Safety check@>

In case something bad has happened and the heap has overflowed the stack area,
we check before we rely on the layout being sane.

@$@<Perform last safety check@>==@{@-
if (hp > (NodePtr)sp) {
    ERROR_OUT("Fatal %3d: hp = %8lx > sp %8lx\n", nogc, (UInt)hp, (UInt)sp);
    EXITPROG(-1);
}
@}

@C@<Update statistical information@>

The following code fragments update the statistical information at
appropriate times.  Note that the total heap usage is incremented by the
size of the heap @/before@/ the collection.

@$@<Increment total heap usage@>==@{@-
hpTotal += (int64_t)(hp - hpBase);
@}

@$@<Increment heap moved and record survival@>==@{@-
{
    Int newsize = hp - &hpLowLimit[GCEXTRA];
    hpMoved += (int64_t)newsize;
    if (hpMaxSurvive < newsize)
        hpMaxSurvive = newsize;
}
@}

@$@<Update collection count@>==@{@-
nogc++;
@}

@C@<Foreign objects@>

Collection of foreign objects is handled by external routines.

@$@<Clear foreign objects@>==@{@-
clearForeignObjs();
@}

@$@<Collect foreign objects@>==@{@-
gcForeignObjs();
@}

@C@<Mark the active nodes@>

Begin by clearing all of the marks.  Then if an allocation is being
performed, mark words reachable via the stack and via CAFs.  In between,
give the user-level garbage collectors a chance to do their marking.

@$@<Mark the active nodes@>==@{@-
@<Log@>@(markClear@);
markClear();
if (size) {
    @<Log@>@(markStack@)
    markStack(sp);
    @<Log@>@(markUserGC@)
    @<Mark user GC@>
    @<Log@>@(markCaf@)
    markCaf();
}
@}

@C@<Flip the pointers@>

FIXME: need proper description of purpose of flipping perhaps as general
overview of collection at the start of this section and a brief reminder
here.

@$@<Flip the pointers@>==@{@-
@<Log@>@(flipCaf@)
flipCaf();
@<Flip user GC@>
@<Log@>@(flipStack@)
flipStack(sp);
@<Log@>@(flipHeap@)
flipHeap(hp);
@}

Flipping a pointer consists of reversing a pointer.  If @{*p@} points to
@{x@} which points to @{y@} which points to @{z@}.  Then we end up with
@{y@} pointing to @{x@} and @{*p@} pointing to @{z@}.

@$@<flip header@>@M==@{@-
void flip(NodePtr *p)
@}

@$@<flip routine@>==@{@-
@<flip header@>
{
    NodePtr tmp = *p;
    if (INSIDE(tmp)) {
        *p = (NodePtr)*tmp;
        *tmp = (Node)p;
    }
}
@}

FIXME: probably not the right place for this routine.

After a collection we need to be able to clear the Caf list.

@$@<Clear the Caf list@>==@{@-
clearCaf();
@}

@$@<clearCaf routine@>==@{@-
static void clearCaf(void)
{
    while(oldCaf != GcEnd) {
        GcConst cptr = oldCaf;
        oldCaf = cptr->next;
        cptr->next = 0;
    }
}
@}

Flipping the CAFs is achieved by running down the @{oldCaf@} linked list
created by the mark phase.  This should contain all of the CAFs that have
been found.  This code mirrors the code in @{markCaf@}.

@$@<flipCaf routine@>==@{@-
void flipCaf(void)
{
    GcConst caf = oldCaf;
    while (caf != GcEnd) {
        GcConst cptr = caf;
        Int size = cptr->sizeArity;
        Int i;
        size = FSTHW(size);

        @<Flip the first word of the CAF@>
        @<Flip the constituents of the CAF@>

        caf = cptr->next;
    }
}
@}

If the first word is an indirection we flip it.

FIXME: why is the first word processed specially?

@$@<Flip the first word of the CAF@>==@{@-
{
    NodePtr *nptr = &cptr->ptr[0];
    if (GET_TAG(nptr) == IND_TAG)
        flip(nptr);
}
@}

Next, we skip over the first word of the CAF node and any extra
information in the node and process rest of the contents one by one.
@{VAP@}s just get added to the CAF list for processing themselves since
they have no remaining arguments.  Indirection nodes we just follow and
flip whatever they point to.

FIXME: constructor applications are errors why?

FIXME: not sure why we need to call addCaf to put them on newCaf here.
Is this for the next collection somehow?

@$@<Flip the constituents of the CAF@>==@{@-
i = (Int)EXTRA+1;
size += (Int)EXTRA+1;
for ( ; i<size; i++) {
    NodePtr nptr = cptr->ptr[i];
    switch (EXT_TAG(nptr)) {
        case VAP_TAG0:
        case VAP_TAG1: {
                Cinfo cinfo = EXT_CINFO(nptr);
                addCaf(CINFO_FINFO(cinfo));
            }
            break;

        case IND_TAG:
            flip(&cptr->ptr[i]);
            break;

        case CON_TAG:
            ERROR_OUT("CON_TAG in markCaf(1)\n");
            EXITPROG(-1);
    }
}
@}

Flipping the stack is a matter of traversing the frames and calling @{flip@}
for each pointer entry.  Recall that each frame consists of a saved @{ip@},
a saved @{fp@} and a sequence of pointer words.  The saved @{fp@} tells us
where the next frame begins.

@$@<flipStack routine@>==@{@-
void flipStack(NodePtr *sp)
{
    NodePtr *sptr;
    for (sptr = sp; sptr < spStart; ) {
        NodePtr *fp;
        sptr++;
        fp = (NodePtr *)*sptr++;
        while (sptr != fp) {
           flip(sptr++);
        }
    }
}
@}

Flipping the heap involves scanning through flipping pointers that we find.
At the same time we label garbage holes for the move phase.

@$@<flipHeap routine@>==@{@-
void flipHeap(NodePtr hp)
{
    NodePtr scanptr, newpos;
    scanptr = newpos = &hpLowLimit[GCEXTRA];
    while (scanptr < hp) {
        @<Scan a hole@>
        @<Flip a node@>
    }
}
@}

Start by scanning a hole that might be at the current point.  We need to
adjust the pointers in subsequent nodes to take into account that the hole
will be removed as the non-garbage is moved down in the move phase.

@$@<Scan a hole@>==@{@-
if (!marked(scanptr)) {
    @<Determine the current bit table position@>
    @<Record the hole start@>
    @<Find the next marked node@>
foundNode:
    @<Label the hole@>
}
@}

To look up the current work in the bit table we need to work out its
position: @{off@} is the word offset into the table and @{mask@} accesses
the appropriate bit in that word.

@$@<Determine the current bit table position@>==@{@-
Int off = scanptr - hpLowLimit+1;
UInt mask = 1l << (off & WORDMASK);
@}

The hole starts at the current location.

@$@<Record the hole start@>==@{@-
NodePtr hole = scanptr;
@}

Find the end of the hole (i.e., the next marked node) by traversing the
bit table looking for the next set bit.

FIXME: The label above and the goto foundNode below don't appear to be
necessary since the then branch just falls through to the right place
anyway.  Delete them?

@$@<Find the next marked node@>==@{@-
UInt cache;
scanptr++;
off >>= WORDSHIFT;
if (@<The current bit table word has a marked bit@>) {
    @<Find the next set bit in the current word@>
    goto foundNode;
} else {
   @<Find the next non-zero word and the first set bit in it@>
}
@}

@$@<The current bit table word has a marked bit@>==@{@-
(0 != (cache = (bitTable[off] & ~(mask-1))))
@}

FIXME: perhaps could simplify this and the next by moving the similar
internal while loops out.

@$@<Find the next set bit in the current word@>==@{@-
while (!(mask & cache)) {
    mask <<= 1;
    scanptr++;
}
@}

@$@<Find the next non-zero word and the first set bit in it@>==@{@-
Int i = 0;
while (0 == (cache = bitTable[++off]))
    ;
mask = 1;
while (!(mask & cache)) {
    mask <<= 1;
    i++;
}
scanptr = hpLowLimit + (off << WORDSHIFT) + i;
@}

At this point @{scanptr@} refers to the next marked node.  We record a
negative version of its location in the first word of the hole to label
that this is the start of a hole that continues until @{scanptr@}.  The
move phase will use this later to easily skip the hole.

@$@<Label the hole@>==@{@-
hole[0] = (Node)-(Int)scanptr;
@}

FIXME: really don't understand exactly what the update is doing.  It seems
to be following a chain of pointers from scanptr and updating them all to
refer to newpos which is the new location of the object.  Is this just updating
indirections?  How does this and the following stuff work if the node isn't
actually stored here.  What about other pointers elsewhere in the heap
referring to this same node?

FIXME: Note that since @{IND_TAG@} is zero we treat indirection nodes as
pointers.

FIXME: not sure why this has an @{nhc_@} prefix and nothing else does.

@$@<nhc_update routine@>==@{@-
Node nhc_update(NodePtr old, NodePtr new)
{
    NodePtr c;
    if (MASK_WTAG & (UInt)(c = (NodePtr)*old)) {
        return (Node) c;
    }
    do {
        NodePtr n = (NodePtr)*c;
        *c = (Node)new;
        c = n;
    } while (!((UInt)c & MASK_WTAG));
    return (Node)c;
}
@}

Having scanned over the hole we now process the node we have found.

FIXME: more description needed

FIXME: The CON_CDATA cases shouldn't be needed.  See also graph and mark
and moveHeap below.

@$@<Flip a node@>==@{@-
if (scanptr < hp) {
    Node tag = nhc_update(scanptr,newpos);
    *scanptr = tag;
    switch (EXT_LARGETAG(tag)) {

        case CON_DATA | VAP_TAG0:
        case CON_PTRS | VAP_TAG0:
        case CON_CDATA | VAP_TAG0:
        case CON_WORDS | VAP_TAG0:
        case CON_DATA | VAP_TAG1:
        case CON_PTRS | VAP_TAG1:
        case CON_CDATA | VAP_TAG1:
        case CON_WORDS | VAP_TAG1: {
                Cinfo cinfo = EXT_CINFO(tag);
                Int size   = CINFO_SIZE(cinfo) + EXTRA;
                Int i = EXTRA;
                scanptr += 1 + i;
                while (i++ < size)
                    flip((NodePtr *)scanptr++);
                newpos += 1 + size;
            }
            break;

        case CON_DATA | CON_TAG:
        case CON_CDATA | CON_TAG: {
                Coninfo cinfo = EXT_CONINFO(tag);
                Int psize = CONINFO_PSIZE(cinfo);
                Int t = CONINFO_SIZE(cinfo);
                newpos += 1 + t + EXTRA;
                t -= psize;
                scanptr += 1 + EXTRA;
                while (psize--)
                    flip((NodePtr *)scanptr++);
                scanptr += t;
            }
            break;

        case CON_PTRS | CON_TAG: {
                Coninfo cinfo = EXT_CONINFO(tag);
                Int size = CONINFO_LARGESIZEU(cinfo);
                newpos += 1 + size + EXTRA;
                scanptr += 1 + EXTRA;
                while (size--)
                    flip((NodePtr *)scanptr++);
            }
            break;

        case CON_WORDS | CON_TAG: {
                Coninfo cinfo = EXT_CONINFO(tag);
                Int size = CONINFO_LARGESIZEU(cinfo);
                newpos += 1 + size + EXTRA;
                scanptr += 1 + size + EXTRA;
            }
            break;

        default:
            ERROR_OUT("Bad tag 0x%x in flip heap!\n", EXT_LARGETAG(tag));
            EXITPROG(-1);
    }
}
@}

@C@<Move the heap@>

@{moveHeap@} actually moves the live heap objects into their new locations
and returns the new heap pointer.  Note that any pointers have already
been updated by the flip phase to refer to where they need to point to in
the new heap.  Thus this phase just needs to move everything down to the
low end of the heap.

@$@<Move the heap@>==@{@-
hp = hpBase = moveHeap(hp);
@}

The heap is moved by walking through from the beginning (given by
@{hpLowLimit[GCEXTRA]@}) to the end (given by @{hp@}).  Note that the
stack is not moved since it cannot contain garbage.  Only the heap is
compacted.  @{scanptr@} is the current location that we are moving from
and @{newpos@} is the current destination.  After everything has moved
@{newpos@} gives the new heap pointer.

@$@<moveHeap routine@>==@{@-
NodePtr moveHeap(NodePtr hp)
{
    NodePtr scanptr, newpos;
    Node tag;

    scanptr = newpos = &hpLowLimit[GCEXTRA];
    while (scanptr < hp) {
        @<Skip over hole@>
        @<Update pointer words@>
        @<Move a node@>
    }
    return newpos;
}
@}

Recall that the flip phase labelled holes by setting the first word of the
hole to the negation of a pointer to the next marked node.  Here we skip
over the holes by detecting the labels as negative words that don't have a
tag (which would mean they are a zapped thunk not a hole indication).

The original @{scanptr@} is recovered from the start of the hole.  If it's
past the end of the hp then we have a hole at the end so we're done and
break out of the loop.  Otherwise, we just continue at the new @{scanptr@}
so we naturally skip the hole.

FIXME: Should the 3 be MASK_WTAG?

@$@<Skip over hole@>==@{@-
Int s = (Int)scanptr[0];
if (s < 0 && !(3 & s)) {
    if ((scanptr = (NodePtr)((UInt)-s)) >= hp)
        break;
}
@}

First, use @{nhc_update@} to update any pointer words up to the next node
header word. @{nhc_update@} returns the header word.

FIXME: this explanation isn't complete or clear.

FIXME: tag doesn't seem the right name for this variable since it actually
contains a node header word not just the tag part.

@$@<Update pointer words@>==@{@-
tag = nhc_update(scanptr,newpos);
@}

Now move the node by extracting the node size from the header and copying the
header and that many words.  Indirection nodes should have been removed by
the mark phase.

FIXME: what happens if the heap ends with a run of pointer words?  Won't
this switch fail?

FIXME: it seems like this code could have less duplication.  Use the switch to
extract the size and then the copying code is the same, isn't it?

FIXME: The CON_CDATA clauses shouldn't be needed.  See also graph and mark
and flipHeap above.

@$@<Move a node@>==@{@-
switch (EXT_LARGETAG(tag)) {
    case CON_DATA | VAP_TAG0:
    case CON_PTRS | VAP_TAG0:
    case CON_CDATA | VAP_TAG0:
    case CON_WORDS | VAP_TAG0:
    case CON_DATA | VAP_TAG1:
    case CON_PTRS | VAP_TAG1:
    case CON_CDATA | VAP_TAG1:
    case CON_WORDS | VAP_TAG1: {
            Cinfo cinfo = EXT_CINFO(tag);
            Int size = CINFO_SIZE(cinfo)+EXTRA;
            *newpos++ = tag;
            scanptr += 1;
            while (size--)
                *newpos++ = *scanptr++;
        }
        break;

    case CON_DATA | CON_TAG:
    case CON_CDATA | CON_TAG: {
            Coninfo cinfo = EXT_CONINFO(tag);
            Int size = CONINFO_SIZE(cinfo)+EXTRA;
            *newpos++ = tag;
            scanptr += 1;
            while (size--)
                *newpos++ = *scanptr++;
        }
        break;

    case CON_PTRS|CON_TAG:
    case CON_WORDS|CON_TAG: {
            Coninfo cinfo = EXT_CONINFO(tag);
            Int size = CONINFO_LARGESIZEU(cinfo)+EXTRA;
            *newpos++ = tag;
            scanptr += 1;
            while (size--)
               *newpos++ = *scanptr++;
        }
        break;

    default:
        ERROR_OUT("Bad tag 0x%x in move heap!\n", EXT_LARGETAG(tag));
        EXITPROG(-1);
}
@}

@C@<Check the requested allocation fits@>

If we have collected all we can and there is still not enough room for the
@{size@} words requested in the current allocation, then we are in
trouble. Report that heap memory has been exhausted and give some
hopefully useful information to help with adjusting the heap size.  Then
abort execution.

@$@<Check that requested allocation fits@>==@{@-
if (hp + size >= (NodePtr)sp) {
    ERROR_OUT("The program ran out of heap memory.");
    ERROR_OUT("  (Current heapsize is %d bytes.)\n", hpSize * sizeof(Node));
    ERROR_OUT("You can set a bigger size with e.g. +RTS -H4M -RTS");
    ERROR_OUT(" (4M = four megabytes).\n");
    ERROR_OUT("GC stats:\n  ");
    ERROR_OUT("  Only %d words after gc, need %ld words.\n", (NodePtr)sp - hp,
              size);
    ERROR_OUT("  Used  %lld words of heap.", (int64_t)(hp - hpBase) + hpTotal);
    ERROR_OUT("  Moved %lld words of heap in %d gcs.\n", hpMoved, nogc);
    ERROR_OUT("  %d words to next gc.", (NodePtr)sp - hp);
    ERROR_OUT("  Max live after gc: %ld words.\n", hpMaxSurvive);
    nhc_abort("Insufficient heap memory.");
}
@}

@C@<Update the heap pointer@>

Finally, we return the new heap pointer so that execution can continue.

@$@<Return new heap pointer@>==@{@-
return hp;
@}

@B@<User-supplied garbage collection@>

To enable the user to provide collection for their own data structures, the
collector maintains @{user_gc@} a linked list of user collectors.  Each
collector must supply a mark and a flip routine.  They are called at the
appropriate points in the mark and flip phases of the main collector.

@$@<User GC types@>==@{@-
typedef void (*markfun)();
typedef void (*flipfun)();

typedef struct USER_GC {
    markfun mark;
    flipfun flip;
    struct USER_GC *next;
} UserGC;
@}

@$@<User GC list@>==@{@-
static UserGC *user_gc = NULL;
@}

@C@<Adding a user collector@>

@{add_user_gc@} adds a new user collector to the list.

@$@<add_user_gc header@>@M==@{@-
void add_user_gc(markfun mark, flipfun flip)@-
@}

@$@<add_user_gc routine@>==@{@-
@<add_user_gc header@>
{
    UserGC *ugc = (UserGC *)MALLOC(sizeof(UserGC));
    if (ugc == NULL) {
        ERROR_OUT("Not enough memory for allocating user GC structure.\n");
        EXITPROG(-1);
    }
    ugc->mark = mark;
    ugc->flip = flip;
    ugc->next = user_gc;
    user_gc = ugc;
}
@}

@C@<Invoking user collectors@>

We invoke the user collector in sequence during the mark and flip phases.

@$@<Mark user GC@>==@{@-
if (user_gc) {
    UserGC *ugc = user_gc;
    @<Log@>@(markuserGC@)
    while (ugc != NULL) {
        ugc->mark();
        ugc = ugc->next;
    }
}
@}

@$@<Flip user GC@>==@{@-
if (user_gc) {
    UserGC *ugc = user_gc;
    @<Log@>@(flipUserGC@)
    while (ugc != NULL) {
        ugc->flip();
        ugc = ugc->next;
    }
}
@}

@B@<Finishing the collection@>

@{finishGc@} gives an opportunity for a final word.

FIXME: we currently don't call this.  The old version called it a couple
of times in haskellEnd under various conditions.

@$@<finishGc header@>@M==@{@-
void finishGc(NodePtr hp, int verbose)@-
@}

@$@<finishGc routine@>==@{@-
@<finishGc header@>
{
    if (verbose) {
        ERROR_OUT("\n\nUsed  %lld words of heap.\n",
                  (int64_t)(hp-hpBase) + hpTotal);
        ERROR_OUT("Moved %lld words of heap in %d gcs.\n", hpMoved, nogc);
        ERROR_OUT("%d words to next gc.\n", hpLimit - hp);
        ERROR_OUT("Max live after gc: %ld words.\n", hpMaxSurvive);
    }
}
@}

@B@<Debugging support@>

@$@<prMemoryLayout routine@>==@{@-
static void prMemoryLayout()
{
    ERROR_OUT("Memory   = %4x .. %4x (%d words)\n", hpStart, hpEnd,
              hpEnd - hpStart);
    ERROR_OUT("Heap     = %4x .. %4x (%d words), base = %4x\n", hpLowLimit,
              hpLimit, hpLimit - hpLowLimit, hpBase);
    ERROR_OUT("Stack    = %4x .. %4x (%d words)\n", spEnd, spStart,
              spStart - spEnd);
    ERROR_OUT("bitTable = %4x (%d words)\n", bitTable, hpEnd - bitTable);
    FLUSH_ERR;
}
@}

@$@<prHeapStack header@>@M==@{@-
void prHeapStack(NodePtr hp, NodePtr *sp, NodePtr *fp)@-
@}

@$@<prHeapStack routine@>==@{@-
static prAddrs(NodePtr base, int incr, int num, int size)
{
    int i;

    if (num > 0) {
        ERROR_OUT("  [ ");
        for (i = 0; i < num; i++, base += incr)
            ERROR_OUT("%4x ", *base);
        if (num != size)
            ERROR_OUT("... ");
        ERROR_OUT("]\n");
    }
}

@<prHeapStack header@>
{
    int stackShow = 8, heapShow = 8;
    int stackSize = spStart - sp;
    int heapSize = hp - hpBase;

    if (stackSize < stackShow)
        stackShow = stackSize;
    ERROR_OUT("\nsp = %4x (%d words), fp = %4x\n", sp, stackSize, fp);
    prAddrs((NodePtr) sp, 1, stackShow, stackSize);

    if (heapSize < heapShow)
        heapShow = heapSize;
    ERROR_OUT("hp = %4x (%d words), %d words free\n", hp, heapSize,
              (NodePtr) sp - hp);
    prAddrs(hp - 1, -1, heapShow, heapSize);
    ERROR_OUT("\n");

    FLUSH_ERR;
}
@}
