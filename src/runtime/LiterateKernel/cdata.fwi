@A@<C data interface@>

This section allows C-level data to be represented and manipulated by the
runtime.  At the very least this support is used to provide access to the
standard I/O streams to support instructions such as @{HGETS@}.  It can
also supports access to foreign objects from Haskell.

@O@<cdata.c@>==@{@-
@<File warning@>

#include <string.h>
#include "mk.h"
#include "stableptr.h"
#include "cinterface.h"

@<Foreign object table@>

@<Pending finalisers queue@>
@<deferGC routine@>
@<runDeferredGCs routine@>

@<gcNow routine@>
@<gcLater routine@>
@<gcNone routine@>
@<gcFile routine@>
@<gcSocket routine@>

@<Standard I/O foreign objects@>

@<initForeignObjs routine@>
@<allocForeignObj routine@>
@<freeForeignObj routine@>
@<derefForeignObj routine@>

@<clearForeignObjs routine@>
@<gcForeignObjs routine@>

@<primForeignObjC routine@>
@<primForeignPtrC routine@>
@<reallyFreeForeignObj routine@>
@}

@$@<Foreign object interface@>==@{@-
@<ForeignObj type@>

extern @<Standard I/O foreign objects@>

extern @<gcNow header@>;
extern @<gcLater header@>;
extern @<gcNone header@>;
extern @<gcFile header@>;
extern @<gcSocket header@>;

extern @<initForeignObjs header@>;
extern @<allocForeignObj header@>;
extern @<freeForeignObj header@>;
extern @<derefForeignObj header@>;

extern @<clearForeignObjs header@>;
extern @<gcForeignObjs header@>;

extern @<runDeferredGCs header@>;
@}

@B@<Foreign objects@>

The @{ForeignObj@} type allows a C value to be carried around with suitable
interfaces to user-defiend garbage collectors.  @{gcf@} is the first stage
collector and @{gc@} is the second-stage.  Both are optional in which case
they can be set to @{NULL@}.

@$@<ForeignObj type@>==@{@-
struct FOREIGNOBJ;

typedef void (*gcFO)(struct FOREIGNOBJ *);
typedef void (*gcCval)(void *);

typedef struct FOREIGNOBJ {
    int    used;
    void*  cval;
    gcCval gc;
    gcFO   gcf;
} ForeignObj;
@}

The registered foreign objects are stored in the @{foreign@} table.

@$@<Foreign object table@>==@{@-
#define MAX_FOREIGNOBJ 1024

static ForeignObj foreign[MAX_FOREIGNOBJ];
@}

@B@<Standard I/O foreign objects@>

As well as facilities for registering new foreign objects, the module
supports the standard I/O streams via the following foreign objects.

@$@<Standard I/O foreign objects@>@M==@{@-
ForeignObj fo_stdin, fo_stdout, fo_stderr;
@}

@B@<Initialisation@>

Initialisation is a matter of clearing the foreign object table and
setting up the special foreign objects for the three standard I/O streams.

@$@<Foreign object initialisation@>==@{@-
initForeignObjs();
@}

@$@<initForeignObjs header@>@M==@{@-
void initForeignObjs()@-
@}

@$@<initForeignObjs routine@>==@{@-
@<initForeignObjs header@>
{
    @<Clear foreign object table@>
    @<Initialise stream@>@(stdin@)
    @<Initialise stream@>@(stdout@)
    @<Initialise stream@>@(stderr@)
}
@}

@$@<Clear foreign object table@>==@{@-
{
    int i;

    for (i = 0; i < MAX_FOREIGNOBJ; i++) {
        foreign[i].used = 0;
        foreign[i].cval = NULL;
        foreign[i].gc   = NULL;
        foreign[i].gcf  = NULL;
    }
}
@}

@$@<Initialise stream@>@(@1@)@M==@{@-
{
    FileDesc *fd_@1;

    fd_@1 = (FileDesc*)malloc(sizeof(FileDesc));
    fd_@1->fp = @1;
    fd_@1->bm = _IOLBF;
    fd_@1->size = -1;
    fd_@1->path = strdup("<@1>");
    fo_@1.used = 1;
    fo_@1.cval = (void*)fd_@1;
    fo_@1.gcf  = gcNone;
}
@}

@B@<Allocation and deallocation@>

@{allocForeignObj@} simply finds the first free slot in the table, inserts the
new object there and returns the address of the table entry.

@$@<allocForeignObj header@>@M==@{@-
ForeignObj* allocForeignObj(void* arg, gcCval finalCV, gcFO finalFO)@-
@}

@$@<allocForeignObj routine@>==@{@-
@<allocForeignObj header@>
{
    int i;
    for (i = 0; i < MAX_FOREIGNOBJ; i++) {
        if (!foreign[i].used) {
            foreign[i].used = 1;
            foreign[i].cval = arg;
            foreign[i].gc   = finalCV;
            foreign[i].gcf  = finalFO;
            return &foreign[i];
        }
    }
    ERROR_OUT("Error: allocation limit (%d) exceeded for Foreign(Obj/Ptr)\n",
              MAX_FOREIGNOBJ);
    return 0;
}
@}

Freeing a foreign object causes its first stage collector and clears the
table entry.

FIXME: this routine and some of the others would probably benefit from
NULL pointer tests on entry.

@$@<freeForeignObj header@>@M==@{@-
void freeForeignObj(ForeignObj *cd)@-
@}

@$@<freeForeignObj routine@>==@{@-
@<freeForeignObj header@>
{
    if (cd->gcf)
        cd->gcf(cd);
    else
        ERROR_OUT("Warning: freeForeignObj called on already-free ForeignObj");
    cd->used = 0;
    cd->gcf  = NULL;
}
@}

@B@<Dereferencing@>

Derefering a foreign object returns the underlying C object.

@$@<derefForeignObj header@>@M==@{@-
void *derefForeignObj(ForeignObj *cd)@-
@}

@$@<derefForeignObj routine@>==@{@-
@<derefForeignObj header@>
{
    return cd->cval;
}
@}

@B@<Garbage collection@>

@{clearForeignObjs@} is called before garbage collection to clear the
table @{used@} flags but not the rest of the entries.  An entry with a
zero @{used@} flag and a non-zero @{gcf@} field needs to be collected.

@$@<clearForeignObjs header@>@M==@{@-
void clearForeignObjs(void)@-
@}

@$@<clearForeignObjs routine@>==@{@-
@<clearForeignObjs header@>
{
    int i;
    for (i = 0; i < MAX_FOREIGNOBJ; i++)
        foreign[i].used = 0;
}
@}

The actual garbage collection is performed by the nominated routines for each
object, called by @{gcForeignObjs@}.

@$@<gcForeignObjs header@>@M==@{@-
void gcForeignObjs(void)@-
@}

@$@<gcForeignObjs routine@>==@{@-
@<gcForeignObjs header@>
{
    int i;
    for (i = 0; i < MAX_FOREIGNOBJ; i++)
    if (foreign[i].used == 0 && foreign[i].gcf) {
        foreign[i].gcf(&foreign[i]);
        foreign[i].gcf = NULL;
    }
}
@}

@B@<Garbage collectors@>

The module provides a number of useful first and second stage collectors.
@{gcNow@}, @{gcLater@} and @{gcNone@} are possible first stage collectors.
@{gcNow@} just calls the second stage collector immediately.  @{gcLater@}
uses @{deferGC@} to arrange for the second stage collector to be called
next time a collection is forced.  Finally, @{gcNone@} doesn't do anything.
In each case the @{cval@} field is cleared to avoid holding a reference
to a dead value.

@$@<gcNow header@>@M==@{@-
void gcNow(ForeignObj *cd)@-
@}

@$@<gcNow routine@>==@{@-
@<gcNow header@>
{
    if (cd->gc)
        cd->gc(cd->cval);
    cd->cval = NULL;
    cd->gc   = NULL;
}
@}

@$@<gcLater header@>@M==@{@-
void gcLater(ForeignObj *cd)@-
@}

@$@<gcLater routine@>==@{@-
@<gcLater header@>
{
    if (cd->gc)
        deferGC(cd->gc);
    cd->cval = NULL;
    cd->gc  = NULL;
}
@}

@$@<gcNone header@>@M==@{@-
void gcNone(ForeignObj *cd)@-
@}

@$@<gcNone routine@>==@{@-
@<gcNone header@>
{
    cd->cval = NULL;
    cd->gc   = NULL;
}
@}

@{gcFile@} and @{gcSocket@} are possible second stage collectors for
files and sockets, respectively.  @{gcFile@} only closes if the file
has not already been closed with @{hClose@}.

FIXME: In both cases: if (a->path) free(a->path); free(a) causes a
seg-fault according to code comments.  Is this still true?

@$@<gcFile header@>@M==@{@-
void gcFile(void *c)@-
@}

@$@<gcFile routine@>==@{@-
@<gcFile header@>
{
    FileDesc *a = (FileDesc*)c;
    if (a->fp)
        fclose(a->fp);
}
@}

@$@<gcSocket header@>@M==@{@-
void gcSocket(void *c)@-
@}

@$@<gcSocket routine@>==@{@-
@<gcSocket header@>
{
    FileDesc *a = (FileDesc*)c;
    close(a->fdesc);
}
@}

@B@<Deferred collection@>

Deferred collectors are stored in a queue by @{deferGC@} until
@{runDeferredGCs@} is called to perform the collection.  Stable pointers
are used so if finaliser gets moved around by garbage collection then the
reference will still be correct.

@$@<Pending finalisers queue@>==@{@-
static StablePtr pending[MAX_FOREIGNOBJ];
int pendingIdx = 0;
@}

@$@<deferGC routine@>==@{@-
static void deferGC(StablePtr finalise)
{
    if (++pendingIdx >= MAX_FOREIGNOBJ) {
        ERROR_OUT("mismatch in limits for ForeignObjs and finalisers.\n");
        EXITPROG(1);
    }
    pending[pendingIdx] = finalise;
}
@}

@{runDeferredGCs@} maintains a mutex in case a finaliser triggers a recursive
garbage collection.  In this case we just refuse to run a second time.

@$@<runDeferredGCs header@>@M==@{@-
void runDeferredGCs(void)@-
@}

@$@<runDeferredGCs routine@>==@{@-
@<runDeferredGCs header@>
{
    static int alreadyRunning = 0;

    if (alreadyRunning) {
        return;
    } else
        alreadyRunning = 1;

    @<Run finalisers@>

    alreadyRunning = 0;
}
@}

We just traverse the queue using the mutator to run each of the finalisers
in turn, taking care to save and restore the mutator state around the
finalisation so we can resume the mutator where it was.

@$@<Run finalisers@>==@{@-
{
    CodePtr IP = Ip;
    NodePtr *SP = Sp;
    NodePtr *FP = Fp;

    @<Run each finaliser@>

    Ip = IP;
    Sp = SP;
    Fp = FP;
}
@}

We iterate through the queue of pending finalisers.  Each one is a stable
pointer that is dereferenced to obtain a heap reference which is then
evaluated. Any return value from the evaluation is discarded. Finally, the
stable pointer itself is freed so it can be collected.

@$@<Run each finaliser@>==@{@-
{
    int i;
    NodePtr n;

    for (i = 1; i <= pendingIdx; i++) {
        n = derefStablePtr(pending[i]);
        C_PUSH(n);
        C_EVALTOS(n);
        C_POP();
        freeStablePtr(pending[i]);
        pending[i] = NULL;
    }
    pendingIdx = 0;
}
@}

@B@<Haskell-visible interface@>

The following FFI functions are visible to the Haskell world and provide
facilities for embedding arbitrary objects (represented by Haskell
addresses) in foreign objects or turning Haskell pointers into foreign
pointers.

Note, we assume that the finaliser already has @{unsafePerformIO@} wrapped
around it, so its type is really @{()@}, not even @{IO ()@}.  Furthermore,
it is wrapped in a box so that the primitive call (which evaluates all
args to WHNF) does not execute it straight away!

Note also that normally one @/cannot@/ return a @{ForeignObj@} complete to
the Haskell world.  nhc98 does allow it, but this is the only occasion
where it actually makes sense.

@{foreign import makeForeignObjC :: Addr -> _E a -> IO ForeignObj@}

@$@<primForeignObjC routine@>==@{@-
void *primForeignObjC(void *addr, NodePtr fbox)
{
    ForeignObj *fo;
    NodePtr finalise;
    finalise = GET_POINTER_ARG1(fbox, 1);
    fo = allocForeignObj(addr, (gcCval)makeStablePtr(finalise), gcLater);
    return nhc_mkCInt((int)fo);
}
@}

@{foreign import newForeignPtr :: FinalizerPtr () -> Ptr a ->
IO (ForeignPtr a)@}

@$@<primForeignPtrC routine@>==@{@-
void *primForeignPtrC(gcCval finaliser, void *addr)
{
    ForeignObj *fo;
    fo = allocForeignObj(addr, finaliser, gcNow);
    return nhc_mkCInt((int)fo);
}
@}

The following function is also visible to the Haskell world to enable
foreign objects to be freed from Haskell.  It @/must@/ be a primitive, not
a foreign import, because the latter mechanism would dereference the
@{ForeignObj@} argument to become just an @{Addr@}, which is the opposite
of what we want here.

@{reallyFreeForeignObj primitive 1 :: ForeignObj -> IO ()@}

@$@<reallyFreeForeignObj routine@>==@{@-
C_HEADER(reallyFreeForeignObj)
{
    NodePtr nodeptr;
    ForeignObj *fo;
    nodeptr = C_GETARG1(1);
    IND_REMOVE(nodeptr);
    fo = (void*)GET_INT_VALUE(nodeptr);
    freeForeignObj(fo);
    C_RETURN(nhc_mkUnit());
}
@}
