@A@<Built-ins@>

This section contains the pre-compiled built-in functions used by the
runtime. The file is essentially one array of words indexed by various
labels identifying the functions entry points, constant tables etc.  

@O@<newbuiltin.c@>==@{@-
#include "node.h"

@<Prelude.primLeave forward refs@>
@<Builtin.hgets forward refs@>
@<Builtin.hputc_ok forward refs@>
@<Builtin.primUnpackCString forward refs@>

@<Start_World code@>
@<Prelude.primLeave code@>
@<Builtin.hgets code@>
@<Standard I/O stream code@>
@<Builtin.hputc_ok code@>
@<Builtin.primUnpackCString code@>

@<Prelude.primLeave name@>
@<Builtin.primUnpackCString name@>
@<Builtin.hgets name@>
@}

@$@<Newbuiltin interface@>==@{@-
@<Start_World entry point@>
@<Prelude.primLeave entry point@>
@<Builtin.hgets entry point@>
@<Builtin.hputc_ok entry point@>
@<Builtin.primUnpackCString entry point@>
@}

@B@<Useful macros@>

Rather than repeat the same pattern of code for each builtin we define some 
useful macros that are parameterised by the name of the builtin.

This macro just builds an extern declaration for the entry point.

@$@<Export builtin@>@(@1@)@M==@{@-
extern Node @1[];
@}

A builtin with no arguments doesn't have the prefix containg (need,have)
type pairs.  The actual bytecode comes from the second parameter.

@$@<Define builtin no args@>@(@2@)@M==@{@-
Node @1[] = {
@2@-
};
@}

A builtin with one argument has the standard (need,have) pair table and a
constant table.  The actual bytecode comes from the second parameter.

@$@<Define builtin one arg@>@(@2@)@M==@{@-
Node @1[] = {
    bytes2word(1,0,0,1),
    useLabel(CT_@1)
};
Node FN_@1[] = {
@2@-
    0,
    useLabel(ST_@1)
};
Node CT_@1[] = {
    HW(0,1),
    0
};
Node F0_@1[] = {
    CAPTAG(FN_@1,1)
};
@}

We need forward references to the constant tables and function name
definition for any non-zero argument builtin.

@$@<Forward references@>@(@1@)@M==@{@-
extern Node CT_@1[];
extern unsigned ST_@1[];
@}

A few of the builtins create empty lists so we have a convenience macro
to abbreviate a reference to the list constructor.

@$@<Empty list@>@M==@{@-
useLabel(C0_Prelude_46_91_93)@-
@}

@B@<Start_World@>

@{Start_World@} returns an initial world value containing two empty lists.

FIXME: insert reference to location of Start_World definition.

@$@<Start_World entry point@>==@{@-
@<Export builtin@>@(Start_World@)
@}

@$@<Start_World code@>==@{@-
@<Define builtin no args@>@(Start_World@,@-
    CONSTR(0,2,0),
    @<Empty list@>,
    @<Empty list@>,
@)
@}

@B@<Prelude.primLeave@>

@{Prelude.primLeave@} just runs the @{EXIT@} instruction to terminate 
everything.

@$@<Prelude.primLeave entry point@>==@{@-
@<Export builtin@>@(FN_Prelude_46primLeave@)
@}

@$@<Prelude.primLeave forward refs@>==@{@-
@<Forward references@>@(Prelude_46primLeave@)
@}

@$@<Prelude.primLeave code@>+=@{@-
@<Define builtin one arg@>@(Prelude_46primLeave@,@-
    bytes2word(EXIT,ENDCODE,0,0),
@)
@}

@$@<Prelude.primLeave name@>==@{@-
unsigned ST_Prelude_46primLeave[] = {
  bytes2word('P','r','e','l')
, bytes2word('u','d','e','.')
, bytes2word('p','r','i','m')
, bytes2word('L','e','a','v')
, bytes2word('e',0,0,0)
};
@}

@B@<Builtin.hgets@>

@{Builtin.hgets@} runs the @{HGETS@} mutator operation to provide characters
lazily.

@$@<Builtin.hgets entry point@>+=@{@-
@<Export builtin@>@(FN_Builtin_46hgets@)
@}

@$@<Builtin.hgets forward refs@>==@{@-
@<Forward references@>@(Builtin_46hgets@)
@}

@$@<Builtin.hgets code@>==@{@-
@<Define builtin one arg@>@(Builtin_46hgets@,@-
    bytes2word(NEEDHEAP_I32,PUSH_ARG_I1,HGETS,RETURN),
    bytes2word(ENDCODE,0,0,0), 
@)
@}

@$@<Builtin.hgets name@>==@{@-
unsigned ST_Builtin_46hgets[] = {
  bytes2word('B','u','i','l')
, bytes2word('t','i','n','.')
, bytes2word('h','g','e','t')
, bytes2word('s',0,0,0)
};
@}

@B@<Builtin.hputc_ok@>

@{Builtin.hputc_ok@} returns a FIXME: something with a single field which
is an empty list.  Work out exactly what this is.

@$@<Builtin.hputc_ok entry point@>==@{@-
@<Export builtin@>@(CF__95Builtin_46hputc_95ok@)
@}

@$@<Builtin.hputc_ok forward refs@>==@{@-
@<Forward references@>@(CF__95Builtin_46hputc_95ok@)
@}

@$@<Builtin.hputc_ok code@>==@{@-
@<Define builtin no args@>@(CF__95Builtin_46hputc_95ok@,@-
    CONSTR(1,1,0),
    @<Empty list@>,
@)
@}

@B@<Standard I/O streams@>

These primitives provide Haskell access to the foreign objects that
represent the standard I/O streams.

@$@<Standard stream primitive@>@(@1@)@M==@{@-
unsigned CF_IO_46@1[] = {
  CONSTRW(1,0)
, useLabel((unsigned *)&fo_@1)
};
@}

@$@<Standard I/O stream code@>==@{@-
@<Standard stream primitive@>@(stdout@)
@<Standard stream primitive@>@(stdin@)
@<Standard stream primitive@>@(stderr@)
@}

@B@<Builtin.primUnpackString@>

@{Builtin.primUnpackString@} runs the @{STRING@} mutator operation to provide
string contents as a list.

@$@<Builtin.primUnpackCString entry point@>==@{@-
@<Export builtin@>@(FN_Builtin_46primUnpackCString@)
@}

@$@<Builtin.primUnpackCString forward refs@>==@{@-
@<Forward references@>@(Builtin_46primUnpackCString@)
@}

@$@<Builtin.primUnpackCString code@>==@{@-
@<Define builtin one arg@>@(Builtin_46primUnpackCString@,@-
    bytes2word(NEEDHEAP_I32,PUSH_ARG_I1,STRING,RETURN),
    bytes2word(ENDCODE,0,0,0), 
@)
@}

@$@<Builtin.primUnpackCString name@>==@{@-
unsigned ST_Builtin_46primUnpackCString[] = {
  bytes2word('B','u','i','l')
, bytes2word('t','i','n','.')
, bytes2word('p','r','i','m')
, bytes2word('U','n','p','a')
, bytes2word('c','k','C','S')
, bytes2word('t','r','i','n')
, bytes2word('g',0,0,0)
};
@}
