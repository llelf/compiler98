\documentclass[a4paper]{llncs}

%% \setlength{\textwidth}{162mm}
%% \setlength{\textheight}{254mm}
%% \setlength{\oddsidemargin}{1cm}
%% \setlength{\evensidemargin}{1cm}

\title{{\em hi} -- hmake interactive -- \\Compiler or Interpreter?}
\subtitle{{\em DRAFT}}
\author{Malcolm Wallace}
\institute{University of York, UK}
\date{Draft - 7th August 2000}

\begin{document}
\maketitle


\section{Interpreters vs. compilers}

%%%  Intro to benefits of interactive systems.   (snip from earlier draft)

After writing some code in some programming language, usually a
programmer wants to run the code on a real machine.  In general, there
are two main routes available for translating human-readable program
text into machine-runnable bit-sequences: a compiler or an interpreter.
To a first approximation, a compiler translates all the code at
once before any of it can be run, whereas an interpreter translates
only one instruction at a time, as it is needed, interspersing the
translation activity with the activity of the program itself.  A pure
interpreter generally runs code much slower than a compiled program,
but tends to have advantages in space-usage and in facilitating
interactive development through eliminating the waiting time before
a program can be run.

Of course, in the real world there is actually more of a spectrum of
possibilities available to the implementor of the language system,
lying somewhere between these two poles.  Various tradeoffs between
compilation speed, runtime speed, space usage, interactivity, and other
factors all contribute to a rich spread of implementations in practice.

For instance, byte-code systems use an intermediate language, located
in complexity somewhere between the source text and the machine code.
They need both a compilation phase from the source to the intermediate
level, performed once only, and a interpretation phase, where each
intermediate instruction is translated at runtime and immediately
executed.  The benefit is reduced code size, at the cost of slower
runtime, compared with a compiled program.  Compared to a pure
interpreter, code size is similar, but runtime speed is faster.

Another variation is dynamic (just-in-time) compilation, first reported
in the 1970s, and recently popularised by several Java systems.
This is similar to a byte-code system, except that a much larger
section of the intermediate code is translated at runtime.  This can
both reduce the amount of jumping between translation and execution,
and also allow a certain amount of dynamic re-use of code that has
already been translated on-the-fly.  Together, these effects can
dramatically boost runtime speed performance whilst retaining the
advantages of smaller code-size.

At a rather different level of thinking, on-line partial evaluation
is a further technique that can (in many cases) regain the speed
benefits of a compiled program starting with just an interpreter for
the language.

However this paper examines the interpreter/compiler distinction from
a slightly different angle, focusing on the importance of interactive
program development.  The interactive, tentative style of writing small
programs which gradually grow larger and more complex is traditionally
supported much better by interpretive systems than by compilers.
For instance, in the context of the Haskell language, the Hugs
system is widely preferred by users over the available compilers
(hbc, ghc, nhc98).

No doubt there is a variety of reasons for this preference,
amongst them the fact that Hugs is relatively small, portable, and
easy to install.  However we hypothesise that the main attraction
is interaction.  In Hugs, it is very easy to ask {\em what if?}
questions -- just try out your brand new function by applying it
to some test data in an expression typed at the command line, and
the answer comes back almost immediately.  Or perhaps you want the
system to tell you the most general type of a function, or in which
module you can find it, or what methods belong to a class, or what
instances of a class are available.  All of this information is
readily available with simple commands.

Yet there is no inherent reason why interactive development should
be limited to interpreters -- in a language such as C which lacks
a commonly-available interpreter, programmers are familiar with
an edit-compile-run cycle for testing individual functions within
programs.  And of course compilers generate, read, and manipulate
all the same kinds of type and class information as interpreters --
in Haskell, compilers even dump module {\em interface files} which
act as a store for a lot of this information.

The key missing element is making these facilities easy to access
quickly, by eliminating tedious mechanical steps such as invoking the
compiler with the right options, or maintaining the {\em Makefile} for
a multi-module project, and so on.  In this paper we describe a small
interactive text-based user interface, {\em hi} (hmake interactive),
that mimics most of the features of Hugs, yet which is simply a thin
layer over any ordinary Haskell compiler (and a couple of other common
tools) which do the real work behind the scenes.

The possible benefits of this approach to providing an interactive
development environment are:

\begin{itemize}
\item
  The friendly familiar environment of Hugs is retained.
\item
  It allows an easy ``step up'' from an interpreter to compiled code.
\item
  Depending on the compiler chosen, it can generate slow code quickly,
  or fast code more slowly, allowing the user to tailor their environment
  to suit their needs.
\item
  It can help the user to write code that is portable across compiler
  implementations, easing the transition between development and a
  final polished product.
\item
  Because the interface itself is small and written in Haskell, it is
  comparatively easy to add new features at will.
\end{itemize}




\section{A hybrid: hmake interactive}

{\em hi} -- hmake interactive -- is a small program, itself written
in Haskell, which imitates many of the interactive features of Hugs.
In this section, we give a brief description of its facilities by
comparison with Hugs.  To make the user feel right at home, we even
have a similar start-up banner and prompt:

{\small
\begin{verbatim}
__   __                 __           _____________________________________
||   ||  ______    ___  || _  ____   hmake interactive (hi):
||___|| || || ||  ___|| ||/  ||__||     Copyright (c) May 2000
||---|| || || || ||__|| ||\_ ||__    http://www.cs.york.ac.uk/fp/hmake/
||   ||                              Report bugs to: malcolm@cs.york.ac.uk
||   || Version: 1.9 (000708)        -------------------------------------
                                         ... Using compiler nhc98 ...

Type :? for help
[Std   module... /grp/haskell/include/nhc98/Prelude.hi]
Prelude> 
\end{verbatim}
}

Underlying this interface is a very basic set of tools.  When the
user types an expression, the interface generates a small program
whose {\tt main} function is simply the evaluation of the expression
-- possibly wrapped within a {\tt print} statement if it does not
already have an I/O type.  Previously, the user has ``loaded'' into
the interactive environment, some modules containing definitions of
functions used in the expression, just as in Hugs.  The generated
program must of course also import these ``loaded'' modules.

The generated program is then handed to the batch tool {\em hmake},
which ensures that all the imported modules are compiled (recursively),
and then invokes the compiler on the program itself.  Finally the
executable program is run, connected to the terminal for standard
input and output.  If there are any errors in compilation or execution,
these are presented exactly as the particular compiler reports them,
without terminating the interactive session.

It can immediately be seen that {\em hi} is an extremely thin layer on
top of the real compilation tools -- in fact it knows next to nothing
about parsing Haskell, and certainly needs no advanced capabilities
such as type-checking or code generation.

\subsection{Features of {\em hi} in common with Hugs}

To illustrate the features of {\em hi} that it shares with Hugs, here
is the complete list of commands reported by {\em hi}'s help command:

\begin{verbatim}
  <expr>              evaluate expression
  :?                  display this list of commands
  :quit               quit
  :load mod [mod...]  load modules (note, not filenames)
  :load               clear all modules
  :reload             repeat last load command
  :also mod [mod...]  load additional modules (note, not filenames)
  :module mod         set module scope for evaluating expressions
  :edit file          edit filename
  :edit               edit current module
  :cd dir             change directory
  :cd                 show current directory
  :dir                list current directory
  :hc compiler        set Haskell compiler to use
  :set options        set hmake/compiler options
  :unset options      remove hmake/compiler options
  :!command           shell escape
\end{verbatim}

Of these, the {\tt :hc} command is essentially the only new feature
not found in Hugs (see subsection below).  Everything else is
standard manipulation of the interactive environment (in essence
the maintenance of a set of currently-available modules), and the
evaluation of expressions within this environment.


\subsection{Features of Hugs lacking in {\em hi}}

Some features of Hugs that do not yet have a corresponding
implementation in {\em hi} are as follows (extracted from Hugs'
help command):

\begin{verbatim}
  :project <filename> use project file
  :type <expr>        print type of expression
  :names [pat]        list names currently in scope
  :info <names>       describe named objects
  :browse <modules>   browse names defined in <modules>
  :find <name>        edit module containing definition of name
  :gc                 force garbage collection
  :version            print Hugs version
\end{verbatim}

The use of project files is essentially obsolete -- Hugs now does
full module-chasing based on {\tt import} declarations in files,
whereas {\em hi} calls the batch tool {\em hmake} to achieve the
same goal.

Otherwise, the main omission within {\em hi} is of the various
commands that provide extra information about function names --
their types, which module they reside in, and so on.  In principle,
it would be straightforward to harvest this information from the
module interface files produced by all Haskell compilers.  (The only
reason we have not done so yet is lack of time to write the parsers
needed for each different interface format.)

The {\tt :type} command is slightly more involved, because in Hugs
it can report the type of any expression, not just of a static
function name.  Even this could be provided by {\em hi} without
having to re-implement Haskell's type system, through a similar
mechanism as expressions are evaluated, viz. generate a small
module containing the expression, compile it, then harvest the
type information from the module interface file.


\subsection{Features of {\em hi} lacking in Hugs}

The one major feature of {\em hi} that goes beyond the facilities that
Hugs can offer is the ability to change Haskell compiler on-the-fly
within the interactive environment (the {\tt :hc} command).  This can
be very helpful for verifying the portability of code across compilers.
The command's implementation is fairly obvious - just remove all
object and interface files pertinent to the current set of modules,
and call the {\em hmake} compilation management tool with the new
compiler to rebuild everything.


\section{Program transformation}
\subsection{A clue to the semantics of interpreter/compiler distinctions}

The most interesting parts of {\em hi} are those which manipulate
program source code.  By viewing these as restricted forms of program
transformation, we can perhaps shed a little light on the exact
semantics of evaluating an expression in an interpretive environment,
as distinct from evaluating a program built by a compiler.

There are two main places where program code is ``transformed''
within {\em hi}: the evaluation of an expression in the environment
of a particular set of modules; and the evaluation of an expression
inside the scope of a single module.  These differ: in the first case,
the expression can refer only to entities exported from the modules
in question; in the second, the expression may additionally refer
to entities defined inside (but not exported from) the module whose
scope is entered.

In the first case, the ``transformation'' is degenerate -- essentially
the expression is embedded textually within a skeleton program.

In the second case, the transformation is more interesting.  Starting
from the module within whose scope the expression is entered, we first
remove the module header and export list (if one exists), replacing it
with {\tt module Main where}.  Now, if a {\tt main} function already
exists within the module, we remove (or rename) it.  Finally, we add a
new {\tt main} function whose definition is the expression of interest.


\subsection{Providing extra features}

Taking the idea of program transformation within the interactive
system a little further, it is not hard to see how to provide new
facilities of extra benefit to the programmer.  As an example, Andy
Gill's Haskell Object Observation Debugger is a very useful recent
addition to the programmer's toolkit.  The programmer uses it by
adding tracing ``probes'' to the source code of his program.  However,
in practice this can be disruptive to the original program, making it more
difficult for the human eye to read.  So perhaps an interactive system
could add these ``probes'' automatically?

But of course.  By a simple internal program transformation, {\em hi}
can add a probe to a function definition without altering the original
source file at all.  The command {\tt :observe ident} places a HOOD
observation on the given identifier inside the scope of a module.
The original definition is renamed, and a new definition introduced
which wraps a call to the debugging observation primitive around a call
to the renamed function.



\section{Evaluation}
\subsection{Speed}

One of the first objections to {\em hi} from Hugs users is that
surely it must seem very slow.  After all, Hugs is renowned for
its almost instantaneous loading/compilation time, whereas the most
widely used Haskell compiler ({\em ghc}) is renowned for its slow
compilation times!  However, not all compilers are equal: for instance
{\em nhc98} falls somewhere between these two extremes -- compilation
is faster than ghc (though not as fast as Hugs), and runtime speed is
faster than Hugs (though not as fast as ghc).

In practice, the turnaround time for loading and compiling a
medium-sized module with {\em nhc98} is well under one second on a
fairly recent 500MHz Intel-based PC under Linux -- well within the
tolerances of most users.

In addition, because {\em hi} uses {\em hmake} as its underlying
compilation manager, it is frequently the case that modules which have
been compiled once (and do not change) do not need to be recompiled,
in which case they can be loaded immediately.

Finally, because compiled code runs faster than code being interpreted
by Hugs, there is a tradeoff between increased compilation waiting
time and decreased runtime, which in many cases comes out in favour
of the compilers.


\subsection{Ability to use different compilers}

Because it can use {\em any} Haskell compiler, {\em hi} encourages the
programmer to experiment with a range of tradeoffs between compile-time
speed, runtime speed, code size and runtime heap usage, across the
interpretive/compiled spectrum of available language implementations.

The ability of the individual user to tune his or her interactive
response times in this manner is very attractive.  Because the same
interactive interface can be used with many backends, the barrier to
trying out different compilers is lowered, and it becomes easier to
find the optimal combination of tools for a particular project and
a particular programmer's temperament.


\subsection{Productivity}

Writing the {\em hi} interactive environment was relatively quick and
easy, given the existence of most of the underlying tools that do the
real work.  See Table 1 for a rough breakdown of the effort spent.
The hardest part of the implementation was configuring {\em hi} to
use all three different possible compiler backends, due to three or
four small but non-standard extensions to Haskell'98 used in the code
transformation scheme.  The Unlit module (for stripping literate code)
was taken directly from an implementation given in early versions of
the Haskell report.

\begin{table}
\begin{center}
\begin{tabular}{lrl}

\multicolumn{1}{c}{module} & \multicolumn{1}{c}{LoC} & \multicolumn{1}{c}{time}
  \\
    HInteractive	& 299	& 2x afternoons \\
    HmakeConfig		& 160	& 2x days \\
    LexModule		&  86	& 1x afternoon \\
    SimpleLineEditor	&  74	& 1x day \\
    Unlit	 	&  65	& none \\
 \hline
    total		& 684	& 1x week \\
\end{tabular}
\caption{Size of code / time to write}
\end{center}
\end{table}


\section{Related Work}

\begin{itemize}
\item
  hbi -- the first Haskell compiler/interpreter hybrid.
\item
  Hugs/ghc -- a recent combined interpreter and compiler for Haskell.
\item
  GUI Integrated Development Environments (e.g. MS Visual Studio)
\end{itemize}

\section{Conclusions}

Haskell is an excellent language for scripting.  It took a very
short time to achieve a useful working prototype of a simple tool,
based on stringing calls to other tools together in a sensible manner.

Re-use of other software, when possible, is highly desirable.  In {\em
hi}, we used three existing compilers and an existing compilation
manager as backends, rather than writing our own from scratch.
We also heavily re-used the user-interface design of Hugs, without
actually using any of its code.  While significantly reducing the
time taken to produce the software, it also significantly reduces
the unfamiliarity barrier to users who might wish to try out the
software.

A user-interface does not have to be complex to be useful.  One great
benefit of writing the user-interface in Haskell is that, due to
its conciseness and clarity, it is very easy to extend.  Users can
add features they desire reasonably quickly and easily, and do it
themselves without having to rely on an external authority to guide
them into the intricacies of the code.

Although {\em hi} is a text based interface, one can imagine that a GUI
interface would not be much harder to write in a functional language,
given a suitable graphical toolkit (cf. the Lambada language which
links Haskell with Java libraries, also GTK+HS and hGLUT which link
Haskell with particular GUI libraries implemented in C).

\section*{References}

\end{document}
