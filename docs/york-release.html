<html><head><title>Release 1.00 of nhc98</title></head>
<body bgcolor=#ffffff>
<table><tr><td width=500>

<center><h1>Release 1.02 of nhc98</h1></center>

<hr>

<h3>Why use the <em>nhc98</em> Haskell compiler?</h3>

<dl>
<dt><em>Because it is easy to install.</em></dt>
<dd> Some people find <em>ghc</em> and <em>hbc</em> difficult to install
  on their machine.  <em>nhc98</em> is about as easy to setup
  as Hugs, and it is as portable too.</dd>

<dt><em>Because you have a small machine.</em></dt>
<dd>  <em>nhc98</em> is designed for space-efficiency.  Compile the same
  program under either <em>ghc</em> or <em>hbc</em>, and compare it with
  that produced by <em>nhc98</em>.  Generally, <em>nhc98</em> produces
  much smaller executables, and runtime space usage is also
  <em>very</em> much smaller.  (With the <em>nhc98</em> Binary library
  you can compress your heap data in addition to the normal savings.)
  Expect to pay a speed penalty though - programs produced by
  <em>nhc98</em> run slower than with <em>ghc</em> or <em>hbc</em>
  (although they are still rather faster than <em>Hugs</em>).</dd>

<dt><em>Because you're a software developer.</em></dt>
<dd> nhc98 comes with comprehensive tool support - hmake, hi, greencard,
  heap profiling, and <em>two</em> debuggers.
  Are you fed up waiting for <em>ghc</em> to compile your programs?
  <em>nhc98</em> can be pretty quick at compiling, even though it
  is not as fast as <em>hbc</em>.  For development work, it can also
  provide a useful check that you are sticking to the Haskell 98
  standard and avoiding compiler-specific extensions.</dd>

<dt><em>Because your programs have strange space behaviour.</em></dt>
<dd>
  <em>nhc98</em> has the most advanced heap profiler in the Haskell
  world [4], allowing you to observe in very fine detail exactly what is
  happening to the heap.  Profile types include producer, construction,
  retainer, biography, and lifetime - and any combination thereof.</dd>

<dt><em>Because your program crashes, or produces the wrong output.</em></dt>
<dd>
  <em>nhc98</em> has <em>two</em> sets of debugging facilities.
  First, Andy Gill's <a href="http://www.haskell.org/hood/">HOOD</a>
  library together with his XML-based debugging browser.
  Second, York's advanced <em>Hat</em> tracing system based on
  redex trails [2,3], also with a graphical browser.  In <em>Hat</em>,
  browsing proceeds
  <em>backwards</em> from the error message or suspicious output value,
  observing and exploring the reduction history of parts of the
  computation.  By answering the question "What function application caused
  the evaluation of this expression?" at each stage, it is possible to
  narrow down program bugs quickly.  (<em>Hat</em> is still part
  of ongoing research, and will continue to be developed for some
  time.)</dd>

</dl>


<h3>What language extensions does <em>nhc98</em> support?</h3>
<p>
Extensions of the Haskell'98 language available in <em>nhc98</em> include:

<ul>
<li>
  <em>Binary data representations.</em> In summary, an additional library
  module provides bit-stream operations and a new Binary class for which
  the compiler fully supports "deriving" clauses.
  Fuller details can be found in [1] and in
  <a href="libs/Binary.html">this documentation</a>.

<li>
  The new common <a href="ffi.html">primitive FFI</a>.

<li>
  The IOExtras library, containing IORefs, IOArrays, trace,
  unsafePerformIO, etc.

<li>
  Andy Gill's Observe.lhs library, used for HOOD debugging.

<li>
  Local forall quantification on datatypes.

<li>
  Extended module namespaces, of the form Long.Hierarchical.Module.Name.

</ul>


<h4>References</h4>
<p>
[1] The Bits Between The Lambdas - Binary Data in a Lazy Functional Language,
    Malcolm Wallace and Colin Runciman, Proceedings of the International
    Symposium on Memory Management, Vancouver, Oct 1998.
    [<a href="ftp://ftp.cs.york.ac.uk/pub/malcolm/ismm98.html">FTP site</a>]

<p>
[2] Tracing Large Functional Computations Using Partial Redex Trails,
    Jan Sparud and Colin Runciman, Proc 9th IFL, St Andrews,
    Springer LNCS 1467, Sept 1997.
    [<a href="ftp://ftp.cs.york.ac.uk/pub/colin/ifl97s.ps.gz">FTP site</a>]

<p>
[3] Tracing Lazy Functional Computations Using Redex Trails, Jan Sparud
    and Colin Runciman, Proc 9th PLILP, Southampton, Springer LNCS
    1292, Sept 1997.
    [<a href="ftp://ftp.cs.york.ac.uk/pub/colin/plilp97.ps.gz">FTP site</a>]

<p>
[4] Heap Profiling for Space Efficiency, Colin Runciman and Niklas R&ouml;jemo,
    2nd Intl School on Advanced Functional Programming, pp.159-183,
    Springer LNCS 1129, Olympia WA, Aug 1996.
    [<a href="ftp://ftp.cs.york.ac.uk/pub/colin/advfp96.ps.gz">FTP site</a>]


<hr>
<p>
The latest updates to these pages are available on the WWW from
<a href="http://www.cs.york.ac.uk/fp/nhc98/">
<tt>http://www.cs.york.ac.uk/fp/nhc98/</tt></a>

<p>
2001.04.25<br>
<a href="http://www.cs.york.ac.uk/fp/">
York Functional Programming Group</a><br>

</td></tr></table>
</body></html>

