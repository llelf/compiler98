<html><head><title>The hmake compilation tool</title></head>
<body bgcolor=#ffffff>
<table><tr><td width=500>

<center><h1>The <em>hmake</em> compilation management tool</h1></center>

<hr>
<p>
<em>Hmake</em> is an intelligent compilation management tool for
Haskell programs.  It automatically extracts dependencies between
source modules, and issues the appropriate compiler commands to
rebuild only those that have changed, given just the name of the
program or module that you want to build.  Yes, you need never
write a <em>Makefile</em> again!

<p>
A particular benefit is that <em>hmake</em> knows about interface
(<em>.hi</em>) files.  Even though a source module has changed, if
its interface file has not changed, then other modules which import
it do not need to be recompiled.

<p>
<em>Hmake</em> is compiler-independent, although it is based on
some earlier compiler-specific tools (<em>hbcmake</em>,
<em>lmlmake</em>, <em>nhc13make</em>).  The installation process
automatically detects which Haskell compilers you have, and
sets up <em>hmake</em> to use any of them.


<h3>Usage</h3>
<p>
The basic option summary is:
<pre>
    Usage: hmake [-nhc98|-hbc|-ghc] [hmake opts] [compiler opts] target ...
</pre>
You can have more than one target: all of them are built.  A target
can be a module (with .hs, .lhs, .gc, or .hi extension), in which case
the module and everything it depends on is compiled, but not linked.

<p>
Alternatively, a target can be a program name (no .hs extension),
in which case the appropriate modules are linked as well as compiled.
An object or archive filename (.o, .a extension) cannot be a target,
but if you add it to the commandline, it will be added into the
final link.

<p>
Most options are passed straight through to the appropriate compiler.
However, <em>hmake</em> understands and strips the following options.
<center>
<table width=400><tr>
<td><b>-nhc98</b><br>
    <b>-hbc</b><br>
    <b>-ghc</b></td>
	<td>specify which compiler you want to use [default is the compiler you built hmake with].</td>
</tr><tr>
<td><b>-q</b></td>
	<td>Quiet - don't echo compilation commands.</td>
</tr><tr>
<td><b>-n</b></td>
	<td>Noexec - echo compilation commands but don't execute them.</td>
</tr><tr>
<td><b>-g</b></td>
	<td>Graph - show module dependency graph (implies -n).</td>
</tr><tr>
<td><b>-M</b></td>
	<td>Makefile - show dependencies in Makefile format (implies -n).</td>
</tr><tr>
<td><b>-Md</b></td>
	<td>as for -M, but treats <b>-d</b> <em>objdir</em> specially.</td>
</tr><tr>
<td><b>-clean</b></td>
	<td>remove all .o files relevant to the given project
           (does not compile anything).</td>
</tr><tr>
<td><b>-realclean</b></td>
	<td>remove all .o and .hi files relevant to the given project
           (does not compile anything).</td>
</tr></table>
</center>

<p>
<em>Hmake</em> also makes use of some compiler options if you specify them.
(That is, the options are used by <em>hmake</em> as well as being
passed on to the compiler.)
<center>
<table width=400><tr>
<td><b>-d</b><em>objdir</em></td>
	<td>Search for (and compile) object files in(to) a separate objdir.</td>
</tr><tr>
<td><b>-P</b><em>dir</em></td>
	<td>Search <em>dir</em> for prelude/stdlib interface files.</td>
</tr><tr>
<td><b>-I</b><em>dir</em><br>
    <b>-i</b><em>dir</em></td>
	<td>Search <em>dir</em> for imported modules - compile them
	if necessary, and link against the resulting <em>.o</em> files.</td>
</tr></table>
</center>

<p>
Some options are passed to the compiler's runtime system (using whatever
underlying mechanism is appropriate for the particular compiler).
<center>
<table width=400><tr>
<td><b>-[Hh]</b><em>size</em></td>
	<td>Compiler's heap size.</td>
</tr><tr>
<td><b>-[ASV]</b><em>size</em></td>
	<td>Compiler's stack size.</td>
</tr><tr>
<td><b>-B</b></td>
	<td>Compiler's garbage collector options.</td>
</tr></table>
</center>

<p>
You can force an option which would otherwise be interpreted by another
part of the system to be passed to the compiler by enclosing it
within <em>+CTS</em> ... <em>-CTS</em> delimiters.  For example, with
<b>nhc98</b>, to set the final executable's default heapsize rather than
the compiler's heapsize, use <em>+CTS -H4mb -CTS</em>.



<h3>Miscellaneous Features</h3>
<p>
Some improvements over previous compilation management tools are:
<ul>
<li>You can store object files in a separate directory from your sources.
<li><em>Hmake</em> understands <em>cpp</em> directives: this is
    particularly useful for imports which differ depending on which
    compiler you are using.
    For example,
<pre>
        #if defined(__HBC__) || defined(__GLASGOW_HASKELL__)
        import Native
        #elsif __NHC__
        import Binary
        #endif
</pre>
    The compiler symbols are defined automatically - you can also define
    other symbols with <em><b>-D</b>sym[=val]</em> on the commandline.
<li>It automatically inserts the <em><b>-cpp</b></em> compiler option, but
    only for those modules which actually require it.
<li>If you specify <em>.o</em> or <em>.a</em> files on the commandline, it
    simply links against them, rather than searching for source dependencies
    for them.
</ul>

<p>
I'd welcome any bug reports, or ideas for other options or behaviours
you would find useful.


<hr>
<p>
The latest updates to this software are available on the WWW from
<a href="http://www.cs.york.ac.uk/fp/hmake/">
<tt>http://www.cs.york.ac.uk/fp/hmake/</tt></a>

<p>
Information last updated: 2000-12-19<br>
<a href="http://www.cs.york.ac.uk/fp/">
York Functional Programming Group</a><br>
Malcolm.Wallace@cs.york.ac.uk

</td></tr></table>
</body></html>

